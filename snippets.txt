**** SNIPPET ****
pascalTriangle_Recursive
vector<vector<int>> generatePascalsTriangle(int numRows) 
{
    if (numRows == 0) {
        return {};
    }
    if (numRows == 1) {
        return {{1}};
    }

    vector<vector<int>> triangle = generatePascalsTriangle(numRows - 1);

    vector<int> currentRow;

    currentRow.push_back(1); 

    for (int i = 1; i < numRows - 1; ++i) {
        currentRow.push_back(triangle[numRows - 2][i - 1] + triangle[numRows - 2][i]);
    }

    currentRow.push_back(1); 

    triangle.push_back(currentRow);

    return triangle;
}

**** TAGS ****

pascalTriangle_using_Recursion 
**** SNIPPET ****
gcd_Recursive
int gcd(int a, int b) 
{
    if (b == 0) 
    {
        return a;
    }
    else 
    {
        return gcd(b, a % b);
    }
}

**** TAGS ****

Find_GCD_using_Recursive 
**** SNIPPET ****
ReverseString_Recursive
string reverseString(const string& str) 
{
    if (str.length() <= 1) {
        return str;
    }
    else 
    {
        return reverseString(str.substr(1)) + str[0];
    }
}

**** TAGS ****

ReverseString_using_Reverse 
**** SNIPPET ****
sumOfDigit_Recursive
int sumOfDigits(int n) 
{
    if (n < 10) 
    {
        return n;
    }
    else 
    {
        return n % 10 + sumOfDigits(n / 10);
    }
}

**** TAGS ****

sumOfDigit_using_Recursion 
**** SNIPPET ****
towerOfHanoi_Recursive
void towersOfHanoi(int numDisks, char sourceRod, char destinationRod, char auxiliaryRod) 
{
    if (numDisks == 1) {
        cout << "Move disk 1 from rod " << sourceRod << " to rod " << destinationRod << endl;
        return;
    }

    towersOfHanoi(numDisks - 1, sourceRod, auxiliaryRod, destinationRod);

    cout << "Move disk " << numDisks << " from rod " << sourceRod << " to rod " << destinationRod << endl;

    towersOfHanoi(numDisks - 1, auxiliaryRod, destinationRod, sourceRod);
}

**** TAGS ****

towerOfHanoi_using_Recursion 
**** SNIPPET ****
binarySearch_Recursive
int binarySearch(const vector<int>& arr, int target, int low, int high) 
{
    if (low > high) {
        return -1; 
    }

    int mid = low + (high - low) / 2;
    
    if (arr[mid] == target) 
    {
        return mid; 
    } 
    else if (arr[mid] < target) 
    {
        return binarySearch(arr, target, mid + 1, high); 
    } 
    else 
    {
        return binarySearch(arr, target, low, mid - 1); 
    }
}

**** TAGS ****

BinarySearch_using_Recursion 
**** SNIPPET ****
Copy_string
void myCopy(char s1[], char s2[])
{
    int i = 0;
    for (i=0; s1[i] != '\0'; i++)
       s2[i] = s1[i];
    s2[i] = '\0';
}

**** TAGS ****

Copy_stringInAnotherString 
**** SNIPPET ****
generateCombinations_Recursive
generateCombinations(const string& input, string current, int index, vector<string>& combinations) 
{t
    if (index == input.size()) 
    {
        combinations.push_back(current);
        return;
    }

    generateCombinations(input, current + input[index], index + 1, combinations);
    
    generateCombinations(input, current, index + 1, combinations);
}

**** TAGS ****

genereteCombinations_using_Recursion 
**** SNIPPET ****
String_Palindrome
bool checkPalindrome(string& s)
{
    int n = s.size();
    int i = 0, j = n - 1;
    while (i < j) {
        if (s[i] != s[j])
            return false;
        i++;
        j--;
    }
    return true;
}

**** TAGS ****

Find_StringIsPalindrome 
**** SNIPPET ****
String_Is_Same
bool isSame(string s1, string s2)
{
    int len1 = s1.length();
    int len2 = s2.length();

    if(len1 != len2)
    {
        return false;
    }
    else
    {
        for(int i = 0; i < len1; i++)
        {
            if(s1[i] != s2[i])
            {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

Find_StringIsSame 
**** SNIPPET ****
find_substring
int findSubstring(const char* str, const char* sub) 
{
    if (!str || !sub)
        return -1; 
    
    int strLen = 0;
    int subLen = 0;
    
    while (str[strLen] != '\0')
        strLen++;
    
    while (sub[subLen] != '\0')
        subLen++;
    
    if (subLen > strLen)
        return -1;
    
    for (int i = 0; i <= strLen - subLen; i++) {
        int j;
        for (j = 0; j < subLen; j++) {
            if (str[i + j] != sub[j])
                break; 
        }
        if (j == subLen)
            return i;
    }
    return -1;
}

**** TAGS ****

Find_Substring 
**** SNIPPET ****
Recursive_BubbleSort
void bubbleSort(int arr[], int n) 
{ 
    if (n == 1) 
        return; 
  
    int count = 0;  
    for (int i=0; i<n-1; i++) 
        if (arr[i] > arr[i+1]){ 
            swap(arr[i], arr[i+1]); 
            count++; 
        } 
        if (count==0) 
            return; 
   
    bubbleSort(arr, n-1); 
}

**** TAGS ****

BubbleSort_using_Recursion 
**** SNIPPET ****
subtraction_Matrix
void sub(int mat1[][100], int mat2[][100], result[][100], int row, int col)
{
    for(int i = 0; i < row; i++)
    {
        for(int  j = 0; j < col; j++)
        {   
            result[i][j] = 0;
            result[i][j] += mat1[i][j] - mat2[i][j];
        }
    }
}

**** TAGS ****

Subtraction_Matrix 
**** SNIPPET ****
String_Length
int length(string &s)
{
    int length;
    for(length  = 0; s[length] != '\0'; length++);

    return length;
}

**** TAGS ****

Find_LenghOfString 
**** SNIPPET ****
Recursive_InsertionSort
void insertionSortRecursive(int arr[], int n) 
{ 
    if (n <= 1) 
        return; 
  
    insertionSortRecursive( arr, n-1 ); 
   
    int last = arr[n-1]; 
    int j = n-2; 
  
    while (j >= 0 && arr[j] > last) 
    { 
        arr[j+1] = arr[j]; 
        j--; 
    } 
    arr[j+1] = last; 
} 

**** TAGS ****

InsertionSort_using_Recursion 
**** SNIPPET ****
Min_Recurusion
int fun(int a[],int n)
{
  int x;
  if(n == 1)
    return a[0];
  else
    x = fun(a, n - 1);
  if(x > a[n - 1])
    return x;
  else
    return a[n - 1];
}

**** TAGS ****

Find_Min_with_Recursion 
**** SNIPPET ****
Power_Recursive
int power(int a, int b)
{
    
    if (b == 0)
    {
        return 1;
    }
    else 
    {
        return a * power(a, b - 1);
    }
}

**** TAGS ****

Find_a_power_b_using_Recursion 
**** SNIPPET ****
Fibonacci_Recursive
int fib(int n) 
{ 
    if (n == 0) 
        return 0; 
  
    if (n == 1 || n == 2) 
        return 1; 
   
    else
        return (fib(n - 1) + fib(n - 2)); 
} 

**** TAGS ****

Find_Fibonacci_Series_using_Recursion 
**** SNIPPET ****
CopyString_Recursive
void myCopy(char s1[], char s2[], int index = 0)
{
    // copying each character from s1 to s2
    s2[index] = s1[index]; 
 
    // if string reach to end then stop 
    if (s1[index] == '\0')  
        return;
 
    // increase character index by one
    myCopy(s1, s2, index + 1); 
}

**** TAGS ****

CopyString_using_Recursion 
**** SNIPPET ****
String_Length_Recursive
int length(const string& s, int index = 0) 
{
    if (s[index] == '\0') 
    {
        return 0;
    }
    else 
    {
        return 1 + length(s, index + 1);
    }
}

**** TAGS ****

Find_StringLenght_using_Recursion 
**** SNIPPET ****
Muitiply_Recursion
int fun(int a, int b) 
{
   if (b == 0)
       return 0;
   if (b % 2 == 0)
       return fun(a+a, b/2);
 
   return fun(a+a, b/2) + a;
}

**** TAGS ****

Muitiply_using_Recursion 
**** SNIPPET ****
RemoveDuplicate
string removeDuplicates(const std::string& str) 
{
    unordered_set<char> seenChars;
    string result;

    for (char c : str) 
    {
        if (seenChars.find(c) == seenChars.end()) 
        {
            result += c;
            seenChars.insert(c);
        }
    }

    return result;
}

**** TAGS ****

Delete_DuplicateInString 
**** SNIPPET ****
Multiply_matrix
void multiplyMatrices(int mat1[][100], int mat2[][100], int result[][100], int rows1, int cols1, int rows2, int cols2) 
{
    if(cols1 != rows2) 
    {
        cout << "Error: Number of columns in the first matrix must be equal to the number of rows in the second matrix" << std::endl;
        return;
    }

    for(int i = 0; i < rows1; ++i) 
    {
        for (int j = 0; j < cols2; ++j) 
        {
            result[i][j] = 0;
            for (int k = 0; k < cols1; ++k) 
            {
                result[i][j] += mat1[i][k] * mat2[k][j];
            }
        }
    }
}

**** TAGS ****

MUitiplyMatrix 
**** SNIPPET ****
Addition_Recursion
int add(int a, int b) 
{
    if (b == 0) {
        return a;
    }
    else 
    {
        return add(a + 1, b - 1);
    }
}

**** TAGS ****

Adition_using_Recursion 
**** SNIPPET ****
add_Matrix
void add(int mat1[][100], int mat2[][100], result[][100], int row, int col)
{
    for(int i = 0; i < row; i++)
    {
        for(int  j = 0; j < col; j++)
        {   
            result[i][j] = 0;
            result[i][j] += mat1[i][j] + mat2[i][j];
        }
    }
}

**** TAGS ****

Add_Matrix 
**** SNIPPET ****
adjoint_Matrix
void adj(int mat[][100], int row, int col)
{
    for(int i = 0; i < row; i++)
    {
        for(int  j = 0; j < col; j++)
        {   
            mat[i][j] = mat[j][i];
        }
    }
}

**** TAGS ****

Adjoint_Matrix 
**** SNIPPET ****
ReverseString
string reverseString(const string& str)
 {
    string reversed;

    for (int i = str.length() - 1; i >= 0; --i) 
    {
        reversed += str[i];
    }

    return reversed;
}

**** TAGS ****

Reverse_String 
**** SNIPPET ****
concatenate_string
string concatenateString(string& str1, const sstring& str2)
{
    str1 += str2; 
    return str1;
}

**** TAGS ****

ConcenateString 
**** SNIPPET ****
Factorial_Recursive
int fact(int n)
{
    if (n < = 1) // base case
        return 1;
    else    
        return n*fact(n-1);    
}

**** TAGS ****

Find_factorial_using_Recursion 
**** SNIPPET ****
ackermann_Recursive
int ackermann(int m, int n) 
{
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ackermann(m - 1, 1);
    else
        return ackermann(m - 1, ackermann(m, n - 1));
}

**** TAGS ****

Ackermann_using_Recursive
**** SNIPPET ****
arraySum_Recursive
int array_sum(int arr[], int n) 
{
    if (n == 0)
        return 0;
    else
        return arr[n - 1] + array_sum(arr, n - 1);
}

**** TAGS ****

Find_SumOfArray_using_Recursion
**** SNIPPET ****
sumOfNaturalNumbers_Recursive
int sum_of_natural_numbers(int n) 
{
    if (n == 0)
        return 0;
    else
        return n + sum_of_natural_numbers(n - 1);
}

**** TAGS ****

sumOfNaturalNumbers_using_Recursion
**** SNIPPET ****
geometric_series_Recursive
double geometric_series(double first_term, double common_ratio, int n) 
{
    if (n == 0)
        return first_term;
    else
        return common_ratio * geometric_series(first_term, common_ratio, n - 1);
}

**** TAGS ****

Find_GeometricSeries_using_Recursion
**** SNIPPET ****
isPrime_Recursive
bool is_prime(int n, int i = 2) 
{
    if (n <= 2)
        return (n == 2) ? true : false;
    if (n % i == 0)
        return false;
    if (i * i > n)
        return true;
    return is_prime(n, i + 1);
}

**** TAGS ****

Find_NumberIsPrime_using_Recursion
**** SNIPPET ****
decimal_to_binary_Recursive
void decimal_to_binary(int decimal) 
{
    if (decimal > 0) {
        decimal_to_binary(decimal / 2);
        cout << decimal % 2;
    }
}

**** TAGS ****

Find_Decimal_to_Binary_using_Recursion
**** SNIPPET ****
Count_Characters_Recursive
int count_characters(const string& str, char target) 
{
    if (str.empty())
        return 0;
    else
        return (str[0] == target) + count_characters(str.substr(1), target);
}

**** TAGS ****

Count_Characters_using_Recursion
**** SNIPPET ****
subset_generator_Recursive
generate_subsets(const vector<int>& nums, int index, vector<int>& subset, vector<vector<int>>& subsets) 
{
    if (index == nums.size()) 
    {
        subsets.push_back(subset);
        return;
    }
    generate_subsets(nums, index + 1, subset, subsets);
    subset.push_back(nums[index]);
    generate_subsets(nums, index + 1, subset, subsets);
    subset.pop_back(); 
}

**** TAGS ****

Subset_Generator_using_Recursion
**** SNIPPET ****
String_isanagram_Recursive
bool is_anagram(string str1, string str2) 
{
    if (str1.empty() && str2.empty())
        return true;
    
    if (str1.length() != str2.length())
        return false;
    
    sort(str1.begin(), str1.end());
    sort(str2.begin(), str2.end());
    
    return str1 == str2;
}

**** TAGS ****

check_isanagram_using_Recursion
**** SNIPPET ****
count_pathsInMatrix_Recursive
int count_paths(int m, int n) 
{
    // Base cases
    if (m == 1 || n == 1)
        return 1;
    // Recursive case
    return count_paths(m - 1, n) + count_paths(m, n - 1);
}

**** TAGS ****

Count_PathsInMatrix_using_Recursion
**** SNIPPET ****
sum_even_fibonacci_Recursive
int sum_even_fibonacci(int n) 
{
    if (n <= 0)
        return 0;
    if (n == 1)
        return 2;
    
    int fib_n = 4 * sum_even_fibonacci(n - 1) + sum_even_fibonacci(n - 2);
    return fib_n;
}

**** TAGS ****

Find_sum_even_fibonacci_using_Recursion
**** SNIPPPET ****
genearte_parenthesis_Recursive
void generateParenthesesHelper(int n, int open, int close, string current, vector<string>& result) 
{
    if (current.length() == 2 * n) {
        result.push_back(current);
        return;
    }
    
    if (open < n)
        generateParenthesesHelper(n, open + 1, close, current + '(', result);
    
    if (close < open)
        generateParenthesesHelper(n, open, close + 1, current + ')', result);
}

**** TAGS ****

generate_parenthesis_using_Recursion
**** SNIPPET ****
print_range_Recursive
void print_range(int start, int end) 
{
    if (start > end)
        return;
    cout << start << " ";
    print_range(start + 1, end);
}

**** TAGS ****

Find_range_using_Recursion
**** SNIPPET ****
Max_in_array_Recursive
int find_max(const vector<int>& arr, int index) 
{
    if (index == arr.size() - 1)
        return arr[index];
    int max_in_rest = find_max(arr, index + 1);
    return max(arr[index], max_in_rest);
}

**** TAGS ****

Find_MaxInarray_using_Recursion
**** SNIPPET ****
binary_to_decimal_Recursive
int binary_to_decimal(const string& binary, int index = 0) 
{
    if (index == binary.length())
        return 0;

    int bit_value = binary[index] - '0'; 
    int power_of_two = 1 << (binary.length() - 1 - index); 
    return bit_value * power_of_two + binary_to_decimal(binary, index + 1);
}

**** TAGS ****

Find_BinarytoDecimal_using_Recursion
**** SNIPPET ****
Fibonacci_sum_Recursive
int fibonacci_sum(int n) 
{
    if (n <= 1)
        return n;
    return fibonacci_sum(n - 1) + fibonacci_sum(n - 2) + 1;
}

**** TAGS ****

Find_sumOfFibonacci_using_Recursion
**** SNIPPET ****
numberIsPerfectSquare_Recursive
bool is_perfect_square(int n, int i = 1) 
{
    // Base case
    if (i * i == n)
        return true;
    if (i * i > n)
        return false;

    // Recursive case
    return is_perfect_square(n, i + 1);
}

**** TAGS ****

check_NumberIsPerfectSquare_using_Recursion
**** SNIPPET ****
productOfarray_Recursive
int array_product(const vector<int>& arr, int index) 
{
    if (index == arr.size())
        return 1;
    return arr[index] * array_product(arr, index + 1);
}

**** TAGS ****

Find_prodectOfarray_using_Recursion
**** SNIPPET ****
count_charactersOfstring_Recursive
int countCharacters(const string& str) 
{
    if (str.empty())
        return 0;
    return 1 + countCharacters(str.substr(1));
}

**** TAGS ****

Count_charactersInstring_using_Recursion
**** SNIPPET ****
sumOfEven_REcursive
int sumOfEven(int n) 
{
    if (n <= 0)
        return 0;
    if (n % 2 == 0)
        return n + sumOfEven(n - 2);
    else
        return sumOfEven(n - 1);
}

**** TAGS ****

Find_SumOfEven_using_Recursion
**** SNIPPET ****
triangulatNumber_Recursive
int triangularNumber(int n) 
{
    if (n == 1)
        return 1;
    return n + triangularNumber(n - 1);
}

**** TAGS ****

Find_Triangular_Number_usign_Recursion
**** SNIPPET ****
sumOfsquare_Recursive
int sumOfSquares(int n) 
{
    if (n == 0)
        return 0;
    return n * n + sumOfSquares(n - 1);
}

**** TAGS ****

Find_SumOfsquare_using_Recursion
**** SNIPPET ****
count_Devisors
int countDivisors(int n, int i = 1, int count = 0) 
{
    if (i > n)
        return count;
    if (n % i == 0)
        count++;
    return countDivisors(n, i + 1, count);
}

**** TAGS ****

Count_DivisorsOfNumber_using_REcursion
**** SNIPPET ****
coutnDigit_REcursive
int countDigits(int n) 
{
    if (n < 10)
        return 1;
    return 1 + countDigits(n / 10);
}

**** TAGS ****

Count_DigitOfNumber_uing_Recursion
**** SNIPPET ****
CountOccurance
int countOccurrences(const string& str, char target, int index = 0) {
    
    if (index >= str.length())
        return 0;
    
    int count = (str[index] == target) ? 1 : 0;
    
    return count + countOccurrences(str, target, index + 1);
}

**** TAGS ****

Count_OccuranceOfCharacter
