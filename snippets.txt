**** SNIPPET ****
pascalTriangle_Recursive
vector<vector<int>> generatePascalsTriangle(int numRows) 
{
    if (numRows == 0) {
        return {};
    }
    if (numRows == 1) {
        return {{1}};
    }

    vector<vector<int>> triangle = generatePascalsTriangle(numRows - 1);

    vector<int> currentRow;

    currentRow.push_back(1); 

    for (int i = 1; i < numRows - 1; ++i) {
        currentRow.push_back(triangle[numRows - 2][i - 1] + triangle[numRows - 2][i]);
    }

    currentRow.push_back(1); 

    triangle.push_back(currentRow);

    return triangle;
}

**** TAGS ****

pascalTriangle_using_Recursion 
**** SNIPPET ****
gcd_Recursive
int gcd(int a, int b) 
{
    if (b == 0) 
    {
        return a;
    }
    else 
    {
        return gcd(b, a % b);
    }
}

**** TAGS ****

Find_GCD_using_Recursive 
**** SNIPPET ****
ReverseString_Recursive
string reverseString(const string& str) 
{
    if (str.length() <= 1) {
        return str;
    }
    else 
    {
        return reverseString(str.substr(1)) + str[0];
    }
}

**** TAGS ****

ReverseString_using_Reverse 
**** SNIPPET ****
sumOfDigit_Recursive
int sumOfDigits(int n) 
{
    if (n < 10) 
    {
        return n;
    }
    else 
    {
        return n % 10 + sumOfDigits(n / 10);
    }
}

**** TAGS ****

sumOfDigit_using_Recursion 
**** SNIPPET ****
towerOfHanoi_Recursive
void towersOfHanoi(int numDisks, char sourceRod, char destinationRod, char auxiliaryRod) 
{
    if (numDisks == 1) {
        cout << "Move disk 1 from rod " << sourceRod << " to rod " << destinationRod << endl;
        return;
    }

    towersOfHanoi(numDisks - 1, sourceRod, auxiliaryRod, destinationRod);

    cout << "Move disk " << numDisks << " from rod " << sourceRod << " to rod " << destinationRod << endl;

    towersOfHanoi(numDisks - 1, auxiliaryRod, destinationRod, sourceRod);
}

**** TAGS ****

towerOfHanoi_using_Recursion 
**** SNIPPET ****
binarySearch_Recursive
int binarySearch(const vector<int>& arr, int target, int low, int high) 
{
    if (low > high) {
        return -1; 
    }

    int mid = low + (high - low) / 2;
    
    if (arr[mid] == target) 
    {
        return mid; 
    } 
    else if (arr[mid] < target) 
    {
        return binarySearch(arr, target, mid + 1, high); 
    } 
    else 
    {
        return binarySearch(arr, target, low, mid - 1); 
    }
}

**** TAGS ****

BinarySearch_using_Recursion 
**** SNIPPET ****
Copy_string
void myCopy(char s1[], char s2[])
{
    int i = 0;
    for (i=0; s1[i] != '\0'; i++)
       s2[i] = s1[i];
    s2[i] = '\0';
}

**** TAGS ****

Copy_stringInAnotherString 
**** SNIPPET ****
generateCombinations_Recursive
generateCombinations(const string& input, string current, int index, vector<string>& combinations) 
{t
    if (index == input.size()) 
    {
        combinations.push_back(current);
        return;
    }

    generateCombinations(input, current + input[index], index + 1, combinations);
    
    generateCombinations(input, current, index + 1, combinations);
}

**** TAGS ****

genereteCombinations_using_Recursion 
**** SNIPPET ****
String_Palindrome
bool checkPalindrome(string& s)
{
    int n = s.size();
    int i = 0, j = n - 1;
    while (i < j) {
        if (s[i] != s[j])
            return false;
        i++;
        j--;
    }
    return true;
}

**** TAGS ****

Find_StringIsPalindrome 
**** SNIPPET ****
String_Is_Same
bool isSame(string s1, string s2)
{
    int len1 = s1.length();
    int len2 = s2.length();

    if(len1 != len2)
    {
        return false;
    }
    else
    {
        for(int i = 0; i < len1; i++)
        {
            if(s1[i] != s2[i])
            {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

Find_StringIsSame 
**** SNIPPET ****
find_substring
int findSubstring(const char* str, const char* sub) 
{
    if (!str || !sub)
        return -1; 
    
    int strLen = 0;
    int subLen = 0;
    
    while (str[strLen] != '\0')
        strLen++;
    
    while (sub[subLen] != '\0')
        subLen++;
    
    if (subLen > strLen)
        return -1;
    
    for (int i = 0; i <= strLen - subLen; i++) {
        int j;
        for (j = 0; j < subLen; j++) {
            if (str[i + j] != sub[j])
                break; 
        }
        if (j == subLen)
            return i;
    }
    return -1;
}

**** TAGS ****

Find_Substring 
**** SNIPPET ****
Recursive_BubbleSort
void bubbleSort(int arr[], int n) 
{ 
    if (n == 1) 
        return; 
  
    int count = 0;  
    for (int i=0; i<n-1; i++) 
        if (arr[i] > arr[i+1]){ 
            swap(arr[i], arr[i+1]); 
            count++; 
        } 
        if (count==0) 
            return; 
   
    bubbleSort(arr, n-1); 
}

**** TAGS ****

BubbleSort_using_Recursion 
**** SNIPPET ****
subtraction_Matrix
void sub(int mat1[][100], int mat2[][100], result[][100], int row, int col)
{
    for(int i = 0; i < row; i++)
    {
        for(int  j = 0; j < col; j++)
        {   
            result[i][j] = 0;
            result[i][j] += mat1[i][j] - mat2[i][j];
        }
    }
}

**** TAGS ****

Subtraction_Matrix 
**** SNIPPET ****
String_Length
int length(string &s)
{
    int length;
    for(length  = 0; s[length] != '\0'; length++);

    return length;
}

**** TAGS ****

Find_LenghOfString 
**** SNIPPET ****
Recursive_InsertionSort
void insertionSortRecursive(int arr[], int n) 
{ 
    if (n <= 1) 
        return; 
  
    insertionSortRecursive( arr, n-1 ); 
   
    int last = arr[n-1]; 
    int j = n-2; 
  
    while (j >= 0 && arr[j] > last) 
    { 
        arr[j+1] = arr[j]; 
        j--; 
    } 
    arr[j+1] = last; 
} 

**** TAGS ****

InsertionSort_using_Recursion 
**** SNIPPET ****
Min_Recurusion
int fun(int a[],int n)
{
  int x;
  if(n == 1)
    return a[0];
  else
    x = fun(a, n - 1);
  if(x > a[n - 1])
    return x;
  else
    return a[n - 1];
}

**** TAGS ****

Find_Min_with_Recursion 
**** SNIPPET ****
Power_Recursive
int power(int a, int b)
{
    
    if (b == 0)
    {
        return 1;
    }
    else 
    {
        return a * power(a, b - 1);
    }
}

**** TAGS ****

Find_a_power_b_using_Recursion 
**** SNIPPET ****
Fibonacci_Recursive
int fib(int n) 
{ 
    if (n == 0) 
        return 0; 
  
    if (n == 1 || n == 2) 
        return 1; 
   
    else
        return (fib(n - 1) + fib(n - 2)); 
} 

**** TAGS ****

Find_Fibonacci_Series_using_Recursion 
**** SNIPPET ****
CopyString_Recursive
void myCopy(char s1[], char s2[], int index = 0)
{
    // copying each character from s1 to s2
    s2[index] = s1[index]; 
 
    // if string reach to end then stop 
    if (s1[index] == '\0')  
        return;
 
    // increase character index by one
    myCopy(s1, s2, index + 1); 
}

**** TAGS ****

CopyString_using_Recursion 
**** SNIPPET ****
String_Length_Recursive
int length(const string& s, int index = 0) 
{
    if (s[index] == '\0') 
    {
        return 0;
    }
    else 
    {
        return 1 + length(s, index + 1);
    }
}

**** TAGS ****

Find_StringLenght_using_Recursion 
**** SNIPPET ****
Muitiply_Recursion
int fun(int a, int b) 
{
   if (b == 0)
       return 0;
   if (b % 2 == 0)
       return fun(a+a, b/2);
 
   return fun(a+a, b/2) + a;
}

**** TAGS ****

Muitiply_using_Recursion 
**** SNIPPET ****
RemoveDuplicate
string removeDuplicates(const std::string& str) 
{
    unordered_set<char> seenChars;
    string result;

    for (char c : str) 
    {
        if (seenChars.find(c) == seenChars.end()) 
        {
            result += c;
            seenChars.insert(c);
        }
    }

    return result;
}

**** TAGS ****

Delete_DuplicateInString 
**** SNIPPET ****
Multiply_matrix
void multiplyMatrices(int mat1[][100], int mat2[][100], int result[][100], int rows1, int cols1, int rows2, int cols2) 
{
    if(cols1 != rows2) 
    {
        cout << "Error: Number of columns in the first matrix must be equal to the number of rows in the second matrix" << std::endl;
        return;
    }

    for(int i = 0; i < rows1; ++i) 
    {
        for (int j = 0; j < cols2; ++j) 
        {
            result[i][j] = 0;
            for (int k = 0; k < cols1; ++k) 
            {
                result[i][j] += mat1[i][k] * mat2[k][j];
            }
        }
    }
}

**** TAGS ****

MUitiplyMatrix 
**** SNIPPET ****
Addition_Recursion
int add(int a, int b) 
{
    if (b == 0) {
        return a;
    }
    else 
    {
        return add(a + 1, b - 1);
    }
}

**** TAGS ****

Adition_using_Recursion 
**** SNIPPET ****
add_Matrix
void add(int mat1[][100], int mat2[][100], result[][100], int row, int col)
{
    for(int i = 0; i < row; i++)
    {
        for(int  j = 0; j < col; j++)
        {   
            result[i][j] = 0;
            result[i][j] += mat1[i][j] + mat2[i][j];
        }
    }
}

**** TAGS ****

Add_Matrix 
**** SNIPPET ****
adjoint_Matrix
void adj(int mat[][100], int row, int col)
{
    for(int i = 0; i < row; i++)
    {
        for(int  j = 0; j < col; j++)
        {   
            mat[i][j] = mat[j][i];
        }
    }
}

**** TAGS ****

Adjoint_Matrix 
**** SNIPPET ****
ReverseString
string reverseString(const string& str)
 {
    string reversed;

    for (int i = str.length() - 1; i >= 0; --i) 
    {
        reversed += str[i];
    }

    return reversed;
}

**** TAGS ****

Reverse_String 
**** SNIPPET ****
concatenate_string
string concatenateString(string& str1, const sstring& str2)
{
    str1 += str2; 
    return str1;
}

**** TAGS ****

ConcenateString 
**** SNIPPET ****
Factorial_Recursive
int fact(int n)
{
    if (n < = 1) // base case
        return 1;
    else    
        return n*fact(n-1);    
}

**** TAGS ****

Find_factorial_using_Recursion 
**** SNIPPET ****
ackermann_Recursive
int ackermann(int m, int n) 
{
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return ackermann(m - 1, 1);
    else
        return ackermann(m - 1, ackermann(m, n - 1));
}

**** TAGS ****

Ackermann_using_Recursive
**** SNIPPET ****
arraySum_Recursive
int array_sum(int arr[], int n) 
{
    if (n == 0)
        return 0;
    else
        return arr[n - 1] + array_sum(arr, n - 1);
}

**** TAGS ****

Find_SumOfArray_using_Recursion
**** SNIPPET ****
sumOfNaturalNumbers_Recursive
int sum_of_natural_numbers(int n) 
{
    if (n == 0)
        return 0;
    else
        return n + sum_of_natural_numbers(n - 1);
}

**** TAGS ****

sumOfNaturalNumbers_using_Recursion
**** SNIPPET ****
geometric_series_Recursive
double geometric_series(double first_term, double common_ratio, int n) 
{
    if (n == 0)
        return first_term;
    else
        return common_ratio * geometric_series(first_term, common_ratio, n - 1);
}

**** TAGS ****

Find_GeometricSeries_using_Recursion
**** SNIPPET ****
isPrime_Recursive
bool is_prime(int n, int i = 2) 
{
    if (n <= 2)
        return (n == 2) ? true : false;
    if (n % i == 0)
        return false;
    if (i * i > n)
        return true;
    return is_prime(n, i + 1);
}

**** TAGS ****

Find_NumberIsPrime_using_Recursion
**** SNIPPET ****
decimal_to_binary_Recursive
void decimal_to_binary(int decimal) 
{
    if (decimal > 0) {
        decimal_to_binary(decimal / 2);
        cout << decimal % 2;
    }
}

**** TAGS ****

Find_Decimal_to_Binary_using_Recursion
**** SNIPPET ****
Count_Characters_Recursive
int count_characters(const string& str, char target) 
{
    if (str.empty())
        return 0;
    else
        return (str[0] == target) + count_characters(str.substr(1), target);
}

**** TAGS ****

Count_Characters_using_Recursion
**** SNIPPET ****
subset_generator_Recursive
generate_subsets(const vector<int>& nums, int index, vector<int>& subset, vector<vector<int>>& subsets) 
{
    if (index == nums.size()) 
    {
        subsets.push_back(subset);
        return;
    }
    generate_subsets(nums, index + 1, subset, subsets);
    subset.push_back(nums[index]);
    generate_subsets(nums, index + 1, subset, subsets);
    subset.pop_back(); 
}

**** TAGS ****

Subset_Generator_using_Recursion
**** SNIPPET ****
String_isanagram_Recursive
bool is_anagram(string str1, string str2) 
{
    if (str1.empty() && str2.empty())
        return true;
    
    if (str1.length() != str2.length())
        return false;
    
    sort(str1.begin(), str1.end());
    sort(str2.begin(), str2.end());
    
    return str1 == str2;
}

**** TAGS ****

check_isanagram_using_Recursion
**** SNIPPET ****
count_pathsInMatrix_Recursive
int count_paths(int m, int n) 
{
    // Base cases
    if (m == 1 || n == 1)
        return 1;
    // Recursive case
    return count_paths(m - 1, n) + count_paths(m, n - 1);
}

**** TAGS ****

Count_PathsInMatrix_using_Recursion
**** SNIPPET ****
sum_even_fibonacci_Recursive
int sum_even_fibonacci(int n) 
{
    if (n <= 0)
        return 0;
    if (n == 1)
        return 2;
    
    int fib_n = 4 * sum_even_fibonacci(n - 1) + sum_even_fibonacci(n - 2);
    return fib_n;
}

**** TAGS ****

Find_sum_even_fibonacci_using_Recursion
**** SNIPPPET ****
genearte_parenthesis_Recursive
void generateParenthesesHelper(int n, int open, int close, string current, vector<string>& result) 
{
    if (current.length() == 2 * n) {
        result.push_back(current);
        return;
    }
    
    if (open < n)
        generateParenthesesHelper(n, open + 1, close, current + '(', result);
    
    if (close < open)
        generateParenthesesHelper(n, open, close + 1, current + ')', result);
}

**** TAGS ****

generate_parenthesis_using_Recursion
**** SNIPPET ****
print_range_Recursive
void print_range(int start, int end) 
{
    if (start > end)
        return;
    cout << start << " ";
    print_range(start + 1, end);
}

**** TAGS ****

Find_range_using_Recursion
**** SNIPPET ****
Max_in_array_Recursive
int find_max(const vector<int>& arr, int index) 
{
    if (index == arr.size() - 1)
        return arr[index];
    int max_in_rest = find_max(arr, index + 1);
    return max(arr[index], max_in_rest);
}

**** TAGS ****

Find_MaxInarray_using_Recursion
**** SNIPPET ****
binary_to_decimal_Recursive
int binary_to_decimal(const string& binary, int index = 0) 
{
    if (index == binary.length())
        return 0;

    int bit_value = binary[index] - '0'; 
    int power_of_two = 1 << (binary.length() - 1 - index); 
    return bit_value * power_of_two + binary_to_decimal(binary, index + 1);
}

**** TAGS ****

Find_BinarytoDecimal_using_Recursion
**** SNIPPET ****
Fibonacci_sum_Recursive
int fibonacci_sum(int n) 
{
    if (n <= 1)
        return n;
    return fibonacci_sum(n - 1) + fibonacci_sum(n - 2) + 1;
}

**** TAGS ****

Find_sumOfFibonacci_using_Recursion
**** SNIPPET ****
numberIsPerfectSquare_Recursive
bool is_perfect_square(int n, int i = 1) 
{
    // Base case
    if (i * i == n)
        return true;
    if (i * i > n)
        return false;

    // Recursive case
    return is_perfect_square(n, i + 1);
}

**** TAGS ****

check_NumberIsPerfectSquare_using_Recursion
**** SNIPPET ****
productOfarray_Recursive
int array_product(const vector<int>& arr, int index) 
{
    if (index == arr.size())
        return 1;
    return arr[index] * array_product(arr, index + 1);
}

**** TAGS ****

Find_prodectOfarray_using_Recursion
**** SNIPPET ****
count_charactersOfstring_Recursive
int countCharacters(const string& str) 
{
    if (str.empty())
        return 0;
    return 1 + countCharacters(str.substr(1));
}

**** TAGS ****

Count_charactersInstring_using_Recursion
**** SNIPPET ****
sumOfEven_REcursive
int sumOfEven(int n) 
{
    if (n <= 0)
        return 0;
    if (n % 2 == 0)
        return n + sumOfEven(n - 2);
    else
        return sumOfEven(n - 1);
}

**** TAGS ****

Find_SumOfEven_using_Recursion
**** SNIPPET ****
triangulatNumber_Recursive
int triangularNumber(int n) 
{
    if (n == 1)
        return 1;
    return n + triangularNumber(n - 1);
}

**** TAGS ****

Find_Triangular_Number_usign_Recursion
**** SNIPPET ****
sumOfsquare_Recursive
int sumOfSquares(int n) 
{
    if (n == 0)
        return 0;
    return n * n + sumOfSquares(n - 1);
}

**** TAGS ****

Find_SumOfsquare_using_Recursion
**** SNIPPET ****
count_Devisors
int countDivisors(int n, int i = 1, int count = 0) 
{
    if (i > n)
        return count;
    if (n % i == 0)
        count++;
    return countDivisors(n, i + 1, count);
}

**** TAGS ****

Count_DivisorsOfNumber_using_REcursion
**** SNIPPET ****
coutnDigit_REcursive
int countDigits(int n) 
{
    if (n < 10)
        return 1;
    return 1 + countDigits(n / 10);
}

**** TAGS ****

Count_DigitOfNumber_uing_Recursion
**** SNIPPET ****
CountOccurance
int countOccurrences(const string& str, char target, int index = 0) {
    
    if (index >= str.length())
        return 0;
    
    int count = (str[index] == target) ? 1 : 0;
    
    return count + countOccurrences(str, target, index + 1);
}

**** TAGS ****

Count_OccuranceOfCharacter
**** SNIPPET ****
isOrthogonalMatrix
// Function to check if a 2D array is an orthogonal matrix
bool isOrthogonalMatrix(int arr[][3], int rows, int cols) {
    if (rows != cols) return false;
    
    int product[3][3] = {};
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < rows; ++j) {
            for (int k = 0; k < cols; ++k) {
                product[i][j] += arr[i][k] * arr[j][k];
            }
        }
    }
    return isIdentityMatrix(product, rows, cols);
}

**** TAGS ****

isOrthogonalMatrix 
**** SNIPPET ****
cumulativeColumnSum
// Function to calculate the column-wise cumulative sum of a 2D array
void cumulativeColumnSum(int arr[][3], int rows, int cols) {
    for (int j = 0; j < cols; ++j) {
        int sum = 0;
        for (int i = 0; i < rows; ++i) {
            sum += arr[i][j];
            arr[i][j] = sum;
        }
    }
}

**** TAGS ****

cumulativeColumnSum 
**** SNIPPET ****
isBandMatrix
// Function to check if a 2D array is a banded matrix (non-zero elements lie on a diagonal and adjacent diagonals)
bool isBandedMatrix(int arr[][3], int rows, int cols) {
    int upperLimit = min(rows, cols) - 1;
    int lowerLimit = -upperLimit;
    
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (abs(i - j) > upperLimit || abs(i - j) < lowerLimit) {
                if (arr[i][j] != 0) return false;
            }
        }
    }
    return true;
}

**** TAGS ****

isBandMatrix 
**** SNIPPET ****
sumOfSecondaryDiagonal
// Function to compute the sum of the secondary diagonal of a square matrix
int sumOfSecondaryDiagonal(int arr[][3], int size) {
    int sum = 0;
    for (int i = 0; i < size; ++i) {
        sum += arr[i][size - 1 - i];
    }
    return sum;
}

**** TAGS ****

sumOfSecondaryDiagonal 
**** SNIPPET ****
isConstantMatrix
// Function to check if a 2D array is a constant matrix (all elements are equal)
bool isConstantMatrix(int arr[][3], int rows, int cols) {
    int constant = arr[0][0];
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (arr[i][j] != constant) {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

isConstantMatrix 
**** SNIPPET ****
averageOfElements_2D_Matrix
// Function to find the average of all elements in a 2D array
double averageOfElements(int arr[][3], int rows, int cols) {
    int sum = 0;
    int count = rows * cols;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            sum += arr[i][j];
        }
    }
    return static_cast<double>(sum) / count;
}

**** TAGS ****

averageOfElements_2D_Array 
**** SNIPPET ****
isLowerTriangular
// Function to check if a 2D array is lower triangular
bool isLowerTriangular(int arr[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = i + 1; j < cols; ++j) {
            if (arr[i][j] != 0) return false;
        }
    }
    return true;
}

**** TAGS ****

isLowerTriangular 
**** SNIPPET ****
isPascalsTriangle
// Function to check if a 2D array is a Pascal's triangle
bool isPascalsTriangle(int arr[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        if (arr[i][0] != 1 || arr[i][i] != 1) {
            return false;
        }
        for (int j = 1; j < i; ++j) {
            if (arr[i][j] != arr[i - 1][j - 1] + arr[i - 1][j]) {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

isPascalsTriangle 
**** SNIPPET ****
isIdentityMatrix
// Function to check if a 2D array is identity matrix
bool isIdentityMatrix(int arr[][3], int rows, int cols) {
    if (!isSquareMatrix(arr, rows, cols)) return false;
    
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if ((i == j && arr[i][j] != 1) || (i != j && arr[i][j] != 0)) {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

isIdentityMatrix 
**** SNIPPET ****
isSparse_Matrix
// Function to check if a 2D array is sparse (contains more zeros than non-zeros)
bool isSparse(int arr[][3], int rows, int cols) {
    int countZeros = 0;
    int countNonZeros = 0;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (arr[i][j] == 0) {
                countZeros++;
            } else {
                countNonZeros++;
            }
        }
    }
    return countZeros > countNonZeros;
}

**** TAGS ****

isSparse_Matrix 
**** SNIPPET ****
rotate90Clockwise_2D_Array
// Function to rotate a square 2D array 90 degrees clockwise
void rotate90Clockwise(int arr[][3], int n) {
    // Transpose the array
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            swap(arr[i][j], arr[j][i]);
        }
    }
    // Reverse each row
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n / 2; ++j) {
            swap(arr[i][j], arr[i][n - 1 - j]);
        }
    }
}

**** TAGS ****

rotate90Clockwise_2D_Array 
**** SNIPPET ****
sumOfColumns_2D_Array
// Function to find the sum of elements in each column of a 2D array
void sumOfColumns(int arr[][3], int rows, int cols) {
    for (int j = 0; j < cols; ++j) {
        int sum = 0;
        for (int i = 0; i < rows; ++i) {
            sum += arr[i][j];
        }
        cout << "Sum of elements in column " << j << ": " << sum << endl;
    }
}

**** TAGS ****

sumOfColumns_2D_Array 
**** SNIPPET ****
int countOccurrencesInArray(const vector<int>& vec, int value) {
    int count = 0;
    for (int num : vec) {
        if (num == value) {
            count++;
        }
    }
    return count;
}

**** TAGS ****

countOccurrencesInArray 
**** SNIPPET ****
reverse_DoublyList
void reverseList(Node* &head,Node* &tail){
    Node* currPtr = head;
    while(currPtr){
        Node* nextPtr = currPtr->next;
        currPtr->next = currPtr->prev;
        currPtr->prev = nextPtr;
        currPtr = nextPtr;
    }
    //swap head and tail
     Node* newHead = tail;
    tail = head;
    head = newHead;
   return;
}

**** TAGS ****

tag_reverse_DoublyList 
**** SNIPPET ****
bubble_sort
void bubblesort(int *arr,int n){

    for(int i=0;i<n;i++)
    {
        for(int j=0;j<i;j++){

            if(arr[i]<arr[j])
            {
               int swap = arr[i];
               arr[i] = arr[j];
               arr[j] = swap;

            }
        }
    }
}

**** TAGS ****

bubble_sort 
**** SNIPPET ****
removeNodeFromLast_Singly
void deleteFromK(Node* &head,int k){
  Node* ptr1 = head;
  Node* ptr2 = head;
  int count = k;
  while(count--) ptr2 = ptr2->next;
  if(ptr2==NULL){//k is equal to length of linked list 
      //we have to delete head node
    Node* temp = head;
    head = head->next;
    free(temp);
    return;
  }
}


**** TAGS ****

tag_removeNodeLast_K_Singly 
**** SNIPPET ****
countOccurrences_2D_Array
// Function to count occurrences of a given element in a 2D array
int countOccurrences(int arr[][3], int rows, int cols, int element) {
    int count = 0;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (arr[i][j] == element) {
                count++;
            }
        }
    }
    return count;
}

**** TAGS ****

countOccurences_2DArray 
**** SNIPPET ****
pascal_Triangle
vector<vector<int>> generatePascalTriangle(int numRows) {
    vector<vector<int>> triangle(numRows);

    for (int i = 0; i < numRows; ++i) {
        triangle[i].resize(i + 1);
        triangle[i][0] = triangle[i][i] = 1; // First and last element of each row is 1

        for (int j = 1; j < i; ++j) {
            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; // Sum of two elements above
        }
    }

    return triangle;
}

void printPascalTriangle(const vector<vector<int>>& triangle) {
    int numRows = triangle.size();
    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j <= i; ++j) {
            cout << triangle[i][j] << " ";
        }
        cout << endl;
    }
}

**** TAGS ****

pascalTriangle 
**** SNIPPET ****
binarySearch
int binarySearch(vector<int>&input,int target){
  
   int lo = 0;//starting point of the search space
   int hi = input.size();//ending point of the search spacce

    while(lo<= hi)
    {
      //calculate mid point of the search space
      int mid = (lo+hi)/2;

        if(input[mid] == target)  return mid;
        else if(input[mid] < target)  lo = mid+1;
        else hi = mid-1;
     }

   return -1;
}

**** TAGS ****

tag_BinarySearch 
**** SNIPPET ****
printArray
void printArray(int arr[], int size) {
    for (int i = 0; i < size; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

**** TAGS ****

printArray 
**** SNIPPET ****
findIndexArray
// Function to find the index of the first occurrence of a value in an array
int findIndexInArray(int arr[], int size, int value) {
    for (int i = 0; i < size; ++i) {
        if (arr[i] == value) {
            return i;
        }
    }
    return -1; // Value not found
}

**** TAGS ****

findIndexInArray 
**** SNIPPET ****
sumBelowMainDiagonal_Array
// Function to find the sum of elements below the main diagonal in a 2D array
int sumBelowMainDiagonal(int arr[][3], int rows, int cols) {
    int sum = 0;
    for (int i = 1; i < rows; ++i) {
        for (int j = 0; j < i; ++j) {
            sum += arr[i][j];
        }
    }
    return sum;
}

**** TAGS ****

sumBelowMainDiagonal 
**** SNIPPET ****
deletePos_DoublyList
void deletePos(Node* &head,int pos){
    //assume pos is less than or equal to length of list
    if(head == NULL) return;
    Node* temp = head;
    int count = 1;
    while(count<pos){
        temp = temp->next;
        count++;
    }
    temp->prev->next = temp->next;
    temp->next->prev = temp->prev;
    free(temp);
    return;
}

**** TAGS ****

tag_deletePos_DoublyList 
**** SNIPPET ****
deleteAtPos_CircularList
void deletePos(Node* &head,int pos){
    if(pos==0){
        deleteHead(head);
        return;
    }
    int curr_pos=0;
    Node* prev = head;
    while(curr_pos != pos-1){
        prev = prev->next;
        curr_pos++;
    }
    //prev is pointing to the Node at pos-1
    Node* temp = prev->next;//Node to be deleted
    prev->next = prev->next->next;
    free(temp); 
}

**** TAGS ****

tag_deleteAtPos_CircularList 
**** SNIPPET ****
deleteAtBeginning_CircularList
   void deleteStart(Node* &head){
    if(head==NULL)
    { 
        return;
    }
    Node* temp = head;
    Node* tail = head;
    while(tail->next!=head){
        tail = tail->next;
    }
    head = head->next;
    tail->next = head;
    free(temp);
}

**** TAGS ****

tag_insertBeginning_CircularList 
**** SNIPPET ****
linearSearch
bool linearSearch(int arr[],int n,int target){
 for(int i=0;i<n;i++){
   if(arr[i] == target){
       return true;
}
}
  return false;
}

**** TAGS ****

LinearSearch 
**** SNIPPET ****
determinant2x2
// Function to compute the determinant of a 2x2 matrix
int determinant2x2(int arr[2][2]) {
    return arr[0][0] * arr[1][1] - arr[0][1] * arr[1][0];
}

**** TAGS ****

determinant2x2 
**** SNIPPET ****
isIsomorphic_String
bool isIsomorphic(string s1,string s2){
       vector<int> v1(128,-1);
       vector<int> v2(128,-1);
       //if strings not match
       if(s1.length()!= s2.length())  return false;
       for(int i=0;i<s1.length();i++){
            //checking if value of character at index i match in both vector
            if(v1[s1[i]]!= v2[s2[i]])  return false;
            v1[s1[i]] = v2[s2[i]] = i;//storing starting position in vectors for characters at index i
       }
       return true;
}

**** TAGS ****

tag_isomorphic_string 
**** SNIPPET ****
quick_sort
int partition(int arr[],int first,int last)
{

    int pivot = arr[last];

    int i = first - 1;//for insrting element which less than pivot element

    int j = first;//for finding element less than pivot element

    for(;j<last;j++)
    {
        if(arr[j]<pivot)
        {
            i++;
            swap(arr[i],arr[j]);

        }
    }

    //now i is pointing to the last element less than last
    //correct position for the pivot element is i+1

     swap(arr[i+1],arr[last]);

      return i+1;
}

void quickSort(int arr[],int first ,int last)
{
    //base case
    if(first>=last) return;

    int pi = partition(arr,first,last);
    quickSort(arr,first,pi-1);
    quickSort(arr,pi+1,last);
}

**** TAGS ****

quick_sort 
**** SNIPPET ****
print_CircularList
 void display(Node* head){
    Node* temp = head;
    cout<<"Circular Linked-List: ";
    do
    {
        cout<<temp->val<<"->";
         temp = temp->next;
    } while (temp!=head);
    cout<<endl;
}

**** TAGS ****

tag_print_CircularList 
**** SNIPPET ****
insertEnd_Circular_List
    void insertEnd(int value){
        Node* new_node = new Node(value);
        if(head==NULL){
            head = new_node;
            new_node->next = head;
            return;
        }
        Node* tail = head;
        while(tail->next!=head){
            tail = tail->next;
        }
        //now tail is pointing to the last node
        tail->next  = new_node;
        new_node->next = head;
}

**** TAGS ****

tag_insertEnd_CircularList 
**** SNIPPET ****
deleteNeighbour_Node_DoublyList
void deleteNeighour(Node* &head,Node* &tail){
  Node* currNode = tail->prev;//second last
  while(currNode!=head){
    Node* prevNode = currNode->prev;
    Node* nextNode = currNode->next;
    if(prevNode->val!=nextNode->val){
        // i need to delete currNode
        prevNode->next = nextNode;
        nextNode->prev = prevNode;
        free(currNode);
    }
    currNode = prevNode;
  }
return;
}

**** TAGS ****

tag_deleteneighbour_Node_DoublyList 
**** SNIPPET ****
isArrayEmpty
// Function to check if a vector is empty
bool isVectorEmpty(const vector<int>& vec) {
    return vec.empty();
}

**** TAGS ****

isArrayEmpty 
**** SNIPPET ****
isArrayPalindrome
// Function to check if a vector is palindrome
bool isVectorPalindrome(const vector<int>& vec) {
    vector<int> reversedVec = vec;
    reverse(reversedVec.begin(), reversedVec.end());
    return vec == reversedVec;
}

**** TAGS ****

IsArrayPalindrome 
**** SNIPPET ****
removeOccurrencesFromArray
// Function to remove all occurrences of a value from an array
int removeOccurrencesFromArray(int arr[], int& size, int value) {
    int count = 0;
    for (int i = 0; i < size; ++i) {
        if (arr[i] == value) {
            count++;
        } else {
            arr[i - count] = arr[i];
        }
    }
    size -= count;
    return count;
}

**** TAGS ****

removeOccuranceFromArray 
**** SNIPPET ****
cumulativeRowSum
// Function to calculate the row-wise cumulative sum of a 2D array
void cumulativeRowSum(int arr[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        int sum = 0;
        for (int j = 0; j < cols; ++j) {
            sum += arr[i][j];
            arr[i][j] = sum;
        }
    }
}

**** TAGS ****

cumulativeRowSum 
**** SNIPPET ****
sumOfRows_2DArray
// Function to find the sum of elements in each row of a 2D array
void sumOfRows(int arr[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        int sum = 0;
        for (int j = 0; j < cols; ++j) {
            sum += arr[i][j];
        }
        cout << "Sum of elements in row " << i << ": " << sum << endl;
    }
}

**** TAGS ****

sumOfRows_2D_Array 
**** SNIPPET ****
inseration_sort
void insertionSort(vector<int> &v)
{
    int n = v.size();

    for(int i=1;i<n;i++)
    {
        int current = v[i];

        int j = i-1;

        while(j>= 0 && v[j]>current)
        {
            v[j+1] = v[j];
            j--;
        }
        v[j+1] = current;
    }

    return;

}

**** TAGS ****

inseration_sort 
**** SNIPPET ****
findMaxIn2DArray
// Function to find the maximum element in a 2D array
int findMaxIn2DArray(int arr[][3], int rows, int cols) {
    int max = arr[0][0];
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (arr[i][j] > max) {
                max = arr[i][j];
            }
        }
    }
    return max;
}

**** TAGS ****

findMaxIn2DArray 
**** SNIPPET ****
isDiagonal2DArray
// Function to check if a 2D array is diagonal
bool isDiagonal2DArray(int arr[][3], int rows, int cols) {
    if (rows != cols) return false;

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (i != j && arr[i][j] != 0) return false;
        }
    }
    return true;
}

**** TAGS ****

isDiagonal2DArray 
**** SNIPPET ****
sort_String
string countSort(string str){
   vector<int> freq(26,0);
   for(int i=0;i<str.length();i++){  
        int index = str[i] - 'a';
        freq[index]++;
   }
 int j=0;
 for(int i=0;i<26;i++)
 {
    while(freq[i]--){
        str[j] = i+'a';
        j++;
    }
 }
return str;
}

**** TAGS ****

tag_Sort_String 
**** SNIPPET ****
sortArrayIn_Assending
// Function to sort elements of a vector in ascending order
void sortVectorAscending(vector<int> &vec) {
    sort(vec.begin(), vec.end());
}

**** TAGS ****

sortArrayAscending 
**** SNIPPET ****
deleteAtPos
void deletePos(Node* &head,int pos){
    if(pos==0){
        deleteHead(head);
        return;
    }
    int curr_pos=0;
    Node* prev = head;
    while(curr_pos != pos-1){
        prev = prev->next;
        curr_pos++;
    }
    //prev is pointing to the Node at pos-1
    Node* temp = prev->next;//Node to be deleted
    prev->next = prev->next->next;
    free(temp); 
}

**** TAGS ****

deleteAtPos_Singly 
**** SNIPPET ****
Reverse_Singly
Node* reverseList(Node* head) {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;
    while (current) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev;
}

**** TAGS ****

tag_Reverse_Singly 
**** SNIPPET ****
bucket_sort
void bucketSort(vector<float> &v,int n)
{
    //step-1 
    vector<vector<float>> bucket(n,vector<float>());

    //step-2 inserting element in the bucket
    for(int i=0;i<n;i++)
    {
        int index = v[i]*n;
        bucket[index].push_back(v[i]);
    }
   
    //step - 3:sorting individual element

     for(int i=0;i<n;i++){
        if(!bucket[i].empty())
        {
            sort(bucket[i].begin(),bucket[i].end());
        }

     }
     //step 4:combining element from the bucket
      int k=0;
      for(int i=0;i<n;i++)
      {
        for(int j=0;j<bucket[i].size();j++)
        {
            v[k++] = bucket[i][j];
            
        }
    }
}

**** TAGS ****

bucket_sort 
**** SNIPPET ****
update_Pos_Singly
void update_Pos(Node* &head,int k,int val){
    Node* temp = head;
    int curr_pos=0;
    while(curr_pos!=k){
        temp=temp->next;
        curr_pos++;
    }
    //temp will pointing to the kth pos
    temp->val = val;
}

**** TAGS ****

tag_update_pos_Singly 
**** SNIPPET ****
findMax
int findMax(int arr[], int size) {
    int max = arr[0];
    for (int i = 1; i < size; ++i) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

**** TAGS ****

findMax 
**** SNIPPET ****
count_sort
void countSort(vector<int>& arr) {
    int maxElement = max(arr.begin(), arr.end());
    int minElement = min(arr.begin(), arr.end());
    int range = maxElement - minElement + 1;

    vector<int> count(range), output(arr.size());
    for (int i = 0; i < arr.size(); ++i)
        ++count[arr[i] - minElement];

    for (int i = 1; i < count.size(); ++i)
        count[i] += count[i - 1];

    for (int i = arr.size() - 1; i >= 0; --i) {
        output[count[arr[i] - minElement] - 1] = arr[i];
        --count[arr[i] - minElement];
    }

    for (int i = 0; i < arr.size(); ++i)
        arr[i] = output[i];
}

**** TAGS ****

countSort 
**** SNIPPET ****
findMaxArray
// Function to find the maximum element in a vector
int findMaxInVector(const vector<int>& vec) {
    if (vec.empty()) {
        return -1; // Return a sentinel value indicating no maximum found
    }
    int max = vec[0];
    for (int i = 1; i < vec.size(); ++i) {
        if (vec[i] > max) {
            max = vec[i];
        }
    }
    return max;
}

**** TAGS ****

findMaxArray 
**** SNIPPET ****
checkArraySort_Desending
// Function to check if a vector is sorted in descending order
bool isVectorSortedDescending(const vector<int>& vec) {
    for (size_t i = 1; i < vec.size(); ++i) {
        if (vec[i] > vec[i - 1]) {
            return false;
        }
    }
    return true;
}

**** TAGS ****

checkArraySort_Desending 
**** SNIPPET ****
insertStart_Doubly_List
void insertPos(Node* &head,int value,int pos){
    //assuming pos is less or equal to length
    Node* temp = head;
    int count = 1;
    while(count<(pos-1)){
        temp = temp->next;
        count++;
    }
    //now temp is pointing to the pos-1 node
    Node* new_node = new Node(value);
    new_node->next = temp->next;
    temp->next = new_node;
    new_node->prev = temp;
    new_node->prev->next = new_node;
    return;
}

**** TAGS ****

tag_insertStart_DoublyList 
**** SNIPPET ****
appendToarray
// Function to append a value to a vector
void appendToVector(vector<int> &vec, int value) {
    vec.push_back(value);
}

**** TAGS ****

appendToVector 
**** SNIPPET ****
isScalarMatrix
// Function to check if a 2D array is a scalar matrix (diagonal elements are equal, off-diagonal elements are zero)
bool isScalarMatrix(int arr[][3], int rows, int cols) {
    if (!isSquareMatrix(arr, rows, cols)) return false;
    
    int diagonalElement = arr[0][0];
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if ((i != j && arr[i][j] != 0) || (i == j && arr[i][j] != diagonalElement)) {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

isScalarMatrix 
**** SNIPPET ****
reverseArray
void reverseArray(int arr[], int size) {
    for (int i = 0; i < size / 2; ++i) {
        swap(arr[i], arr[size - i - 1]);
    }
}

**** TAGS ****

reverseArray 
**** SNIPPET ****
two_List_EqualOrNot_Singly
bool checkLL(Node* head1,Node* head2){
    Node* ptr1 = head1;
    Node* ptr2 = head2; 
    while(ptr1!=NULL && ptr2!= NULL){
       if(ptr1->val!=ptr2->val) {
        return false;
       }
       ptr1 = ptr1->next;
       ptr2 = ptr2->next;
    }
     //in this case either ptr1 null or ptr2 null or both are null
     return (ptr1==NULL && ptr2==NULL);
}

**** TAGS ****

tag_Check_List_EqualOrNot_Singly 
**** SNIPPET ****
insertAtBegin
void insertAtBeginning(Node* &head,int value){
   Node* newNode = new Node(value);
   if(head == NULL){
     head = newNode;
     return;
    }
    newNode->next = head;
    head = newNode;
}

**** TAGS ****

TagInsertBegin 
**** SNIPPET ****
areArrayEqual
bool areVectorsEqual(const vector<int>& vec1, const vector<int>& vec2) {
    return vec1 == vec2;
}

**** TAGS ****

areArrayEqual 
**** SNIPPET ****
insertAtBeginning_CircularList
void insertAtBegin(int value){
        Node* new_node = new Node(value);
        if(head == NULL){
            head = new_node;
            new_node->next = head;
            return;
        }
        Node* tail = head;
        while(tail->next!=head){
            tail = tail->next;
        }
        //now tail is pointing to the last node
        tail->next = new_node;
        new_node->next = head;
        head = new_node;
         return;
} 

**** TAGS ****

tag_insertAtBeginning_CircularList 
**** SNIPPET ****
insertPos_Singly
void insert_Pos(Node* &head,int val,int pos){
     if(pos==0){
        insert_start(head,val);
        return;
     }
     Node* new_node = new Node(val);
     Node *temp = head;
     int curr_pos=0;
     while(curr_pos != pos-1){
        temp=temp->next;
        curr_pos++;
     } 
     //temp is pointing to node at pos-1
     new_node->next = temp->next;//temp->next is pointing to the at pos
      temp->next = new_node;
}

**** TAGS ****

Tag_InsertPos_Singly 
**** SNIPPET ****
selection_sort
void selectionSort(vector<int> &v)
{

    int n = v.size();

    for(int i=0;i<n-1;i++)
    {
        int min_idx = i;
     

          for(int j=i+1;j<n;j++)
          {
            if(v[j]<v[min_idx])
            {
                min_idx = j;
            }

          }

          if(i != min_idx)
          {
            swap(v[i],v[min_idx]);
              
          }
    }
}

**** TAGS ****

selectionSort 
**** SNIPPET ****
merge_sort
void merge(int arr[] ,int l,int mid,int r){

    int an = mid-l+1;
    int bn = r - mid;

    int a[an],b[bn];

    for(int i=0;i<an;i++) a[i] = arr[l+i];
    for(int j=0;j<bn;j++)  b[j] = arr[mid+1+j];

    int i=0;//initial index for first subarray ,a
    int j=0;//initial index for second subarray,b
    int k = l;//initial index for combine array

    while(i<an || j<bn)
    {
        if(a[i]<b[j]){
            arr[k++] = a[i++];
        }
        else{
            arr[k++] = b[j++];
        }

      }

   //if in uppear condition you put && logical operator then write 
   //these two while loop
   /* while(i<an)   arr[k++] = a[i++];
    while(j<bn)   arr[k++] = b[j++];
    */
}
void mergeSort(int arr[],int l,int r){
    
    if(l>=r) return;

    int mid = (l+r)/2;

    mergeSort(arr,l,mid);
    mergeSort(arr,mid+1,r);
    merge(arr,l,mid,r);

}

**** TAGS ****

merge_sort 
**** SNIPPET ****
reverseListKtime_Singly
Node* reverseK(Node* &head,int k){
    Node* prevptr = NULL;
    Node* currptr = head;
    int counter = 0;//for counting first k nodes
    while(currptr!=NULL && counter<k){//reversing first k nodes
        Node* nextptr = currptr->next;
        currptr->next = prevptr;
        prevptr = currptr;
        currptr = nextptr;
        counter++;
    }
    //current pointer gives (k+1) pointer
    if(currptr!= NULL){
    Node* new_head = reverseK(currptr,k);//recursive call
     head->next = new_head;
    }
    return prevptr;//previous pointer give us the new_head of connected linked list 
}

**** TAGS ****

tag_reverseListKtime_Singly 
**** SNIPPET ****
isSymmetric2DArray
// Function to check if a 2D array is symmetric
bool isSymmetric2DArray(int arr[][3], int rows, int cols) {
    if (rows != cols) return false;

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < i; ++j) {
            if (arr[i][j] != arr[j][i]) return false;
        }
    }
    return true;
}

**** TAGS ****

isSymmetric2DArray 
**** SNIPPET ****
removeDuplicates
// Function to remove duplicates from a vector
void removeDuplicates(vector<int> &vec) {
    vector<int> unique;
    for (int num : vec) {
        if (!vectorContains(unique, num)) {
            unique.push_back(num);
        }
    }
    vec = unique;
}

**** TAGS ****

removeDuplicate 
**** SNIPPET ****
sumAboveMainDiagonal
// Function to find the sum of elements above the main diagonal in a 2D array
int sumAboveMainDiagonal(int arr[][3], int rows, int cols) {
    int sum = 0;
    for (int i = 0; i < rows; ++i) {
        for (int j = i + 1; j < cols; ++j) {
            sum += arr[i][j];
        }
    }
    return sum;
}

**** TAGS ****

sumAboveMainDiagonal 
**** SNIPPET ****
findSecondLargestInArray
// Function to find the second largest element in an array
int findSecondLargestInArray(int arr[], int size) {
    int largest = arr[0], secondLargest = INT_MIN;
    for (int i = 1; i < size; ++i) {
        if (arr[i] > largest) {
            secondLargest = largest;
            largest = arr[i];
        } else if (arr[i] > secondLargest && arr[i] != largest) {
            secondLargest = arr[i];
        }
    }
    return secondLargest;
}

**** TAGS ****

findSecondLargestArray 
**** SNIPPET ****
detect_Cycle_Singly
bool detectCycle(Node* head){
    if(!head) {
        return false;
    }
   Node* slow = head;
   Node* fast = head;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast) {
            return true;
        }
    }
  return false;
}

**** TAGS ****

tag_detect_Cycle_Singly 
**** SNIPPET ****
isUpperTriangular
// Function to check if a 2D array is upper triangular
bool isUpperTriangular(int arr[][3], int rows, int cols) {
    for (int i = 1; i < rows; ++i) {
        for (int j = 0; j < i && j < cols; ++j) {
            if (arr[i][j] != 0) return false;
        }
    }
    return true;
}

**** TAGS ****

isUpperTriangular 
**** SNIPPET ****
dotProduct
// Function to compute the dot product of two vectors
int dotProduct(const vector<int>& vec1, const vector<int>& vec2) {
    int result = 0;
    for (size_t i = 0; i < vec1.size() && i < vec2.size(); ++i) {
        result += vec1[i] * vec2[i];
    }
    return result;
}

**** TAGS ****

dotProduct_Array 
**** SNIPPET ****
SearchInSingly
bool searchInList(const Node* head, int val) {
    const Node* temp = head;
    while (temp) {
        if (temp->data == val) {
            return true;
        }
        temp = temp->next;
    }
    return false;
}

**** TAGS ****

Tag_SearchInList 
**** SNIPPET ****
checkElementInArrayUnique
// Function to check if a vector contains only unique elements
bool areAllElementsUnique(const vector<int>& vec) {
    vector<int> sortedVec = vec;
    sort(sortedVec.begin(), sortedVec.end());
    for (size_t i = 1; i < sortedVec.size(); ++i) {
        if (sortedVec[i] == sortedVec[i - 1]) {
            return false;
        }
    }
    return true;
}

**** TAGS ****

checkElementInArrayUnique 
**** SNIPPET ****
deleteEnd_Doubly
void deleteEnd(){
    if(head == NULL) {
        return;
    }
    Node* temp = tail;
    tail = tail->prev; 
    if(tail==NULL){
         head = NULL;
    }
    else {
        tail->next = NULL;
    }
    free(temp);
   return;    
}

**** TAGS ****

tag_DeleteEnd_DoublyList 
**** SNIPPET ****
node
class Node{
public:
   int val;
   Node* next;
   Node(int data){
     val = data;
     next = NULL;
}
};

**** TAGS ****

Nodecode 
**** SNIPPET ****
partitionArray
// Function to partition a vector into two vectors based on a predicate function
void partitionVector(const vector<int>& vec, vector<int>& trueVec, vector<int>& falseVec, function<bool(int)> pred) {
    for (int num : vec) {
        if (pred(num)) {
            trueVec.push_back(num);
        } else {
            falseVec.push_back(num);
        }
    }
}

**** TAGS ****

partitionArray 
**** SNIPPET ****
rotateArrayRight
// Function to rotate elements in a vector to the right by a specified number of positions
void rotateVectorRight(vector<int>& vec, int positions) {
    if (vec.empty()) return;
    positions %= vec.size();
    rotate(vec.rbegin(), vec.rbegin() + positions, vec.rend());
}

**** TAGS ****

rotateArrayRight 
**** SNIPPET ****
countEvenInArray
// Function to count the number of even elements in an array
int countEvenInArray(int arr[], int size) {
    int count = 0;
    for (int i = 0; i < size; ++i) {
        if (arr[i] % 2 == 0) {
            count++;
        }
    }
    return count;
}

**** TAGS ****

countEvenInArray 
**** SNIPPET ****
roateArrayLeft
void rotateVectorLeft(vector<int>& vec, int positions) {
    if (vec.empty()) return;
    positions %= vec.size();
    rotate(vec.begin(), vec.begin() + positions, vec.end());
}

**** TAGS ****

rotateArrayLeft 
**** SNIPPET ****
isPalindrome_DoublyList
bool isPalindrome(Node* head,Node* tail){
   while(head!=tail && tail!=head->prev){
     if(head->val!=tail->val) return false;
     head = head->next;
     tail = tail->prev;
   }
   return true;
}

**** TAGS ****

tag_isPalindrome_DoublyList 
**** SNIPPET ****
findIndexOfMaxInArray
// Function to find the index of the maximum element in an array
int findIndexOfMaxInArray(int arr[], int size) {
    int maxIndex = 0;
    for (int i = 1; i < size; ++i) {
        if (arr[i] > arr[maxIndex]) {
            maxIndex = i;
        }
    }
    return maxIndex;
}

**** TAGS ****

findIndexOfMaxInArray 
**** SNIPPET ****
isAntiDiagonalMatrix
// Function to check if a 2D array is an anti-diagonal matrix (all non-diagonal elements are zero)
bool isAntiDiagonalMatrix(int arr[][3], int rows, int cols) {
    if (!isSquareMatrix(arr, rows, cols)) return false;
    
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            if (i + j != rows - 1 && arr[i][j] != 0) {
                return false;
            }
        }
    }
    return true;
}

**** TAGS ****

isAntiDiagonalMatrix 
**** SNIPPET ****
areArrayDisjoint
// Function to check if two vectors are disjoint (have no common elements)
bool areVectorsDisjoint(const vector<int>& vec1, const vector<int>& vec2) {
    for (int num1 : vec1) {
        if (find(vec2.begin(), vec2.end(), num1) != vec2.end()) {
            return false;
        }
    }
    return true;
}

**** TAGS ****

areArrayDisjoint 
**** SNIPPET ****
deleteDupliCate_Singly
void deleteDuplicate(Node* &head){
  Node *current_node = head;
  while(current_node){
    while(current_node->next && current_node->val==current_node->next->val){
        //delete curr->next
        Node* temp = current_node->next;//node to be deleted
        current_node->next = current_node->next->next;
        free(temp);
    }
    //this loops ends when current node and next node values are different
    //or linked list ends
    current_node=current_node->next;
  }    
  return;
}

**** TAGS ****
tag_deleteDuplicate_Singly 
**** SNIPPET ****
removeAllOccuranceFromArray
// Function to remove all occurrences of a value from a vector
void removeAllOccurrencesFromVector(vector<int>& vec, int value) {
    vec.erase(remove(vec.begin(), vec.end(), value), vec.end());
}

**** TAGS ****

removeAllOccuranceFromArray 
**** SNIPPET ****
insertAtEnd
void insertAtEnd(Node*& head, int value) {
    Node* newNode = Node(value);
    if (head == NULL) {
        head = newNode;
        return;
    }
        Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newNode;
    
}

**** TAGS ****

tagInsertEnd 
**** SNIPPET ****
RotateByK_Singly
Node* rotateByK(Node* &head,int k){
  //1.find length of the linked list
  int n=0;
 //2. find tail Node
 Node* tail = head;
 while(tail->next!= NULL){
   n++;
   tail = tail->next;
 }
 n++;//for including last node
k = k % n;
if(k==0){ 
   return head;
   }
tail->next = head;
//3.travese n-k nodes
Node* temp = head;
for(int i=1;i<n-k;i++){
   temp = temp->next;
}
//now temp is pointing to the n-k node
 Node* new_node = temp->next;
temp->next=NULL;
 return new_node;
}

**** TAGS ****

tag_RotateByK_Singly 
**** SNIPPET ****
node_DoublyList
class Node{
    public:
    int val;
    Node* next;
    Node* prev;
    Node(int data){
        val = data;
        next = NULL;
        prev = NULL;
    }
};

**** TAGS ****

tag_Node_DoublyLis 
**** SNIPPET ****
insertPos_CircularList
void insertPos(Node* &head,int value,int pos){
      if(pos==0){
        return;
      }
      Node* new_node = new Node(value);
      Node* tail = head;
      int currPos = 0;
      while(currPos!=pos-1){
        tail = tail->next;
        currPos++;
      }  
      //now tail is pointing to pos-1 node
      new_node->next = tail->next;
      tail->next = new_node;
}

**** TAGS ****

tag_insertPos_CircularList 
**** SNIPPET ****
insertEnd_DoublyList
void insertEnd(Node* &head,int value){
  Node* new_node = new Node(value);
  if(tail == NULL){
    head = new_node;
    tail = new_node;
    return;
  }
  tail->next = new_node;
  new_node->prev = tail;
  tail = new_node;
  return;
}

**** TAGS ****

tag_insertEnd_DoublyList 
**** SNIPPET ****
class_Of_SinglyList
class Node{
  public:
     int val;
     Node* next;

     Node(int data){
        val = data;
        next = NULL;
     }

};

class LinkedList{
    public:
     Node *head;

     LinkedList(){
        head = NULL;
     }

     void insertTail(int value){

        Node* new_node = new Node(value);

        if(head == NULL){//if list is empty
           head = new_node;
           return;
        }

        Node *temp = head;
       while(temp->next!= NULL)
       {
        temp = temp->next;
       }
          temp->next = new_node;
     }

     void display(){
     
        Node* temp = head;

        while(temp!= NULL){
            cout<<temp->val<<"->";
            temp = temp->next;
        }        
          cout<<"NULL"<<endl;
     }
};

**** TAGS ****

class_Of_SinglyList 
**** SNIPPET ****
binarySearch_Recursive
int binarysearchRec(vector<int> &input,int target,int lo,int hi)
{
    if(lo>hi){ 
        return -1;
    }

    int mid = (lo+hi)/2;

    if(input[mid] == target) return mid;
    else if(input[mid]<target)  return binarysearchRec(input,target,mid+1,hi);
    else return binarysearchRec(input,target,lo,mid-1);
}

**** TAGS ****

binarySearch_Recursive 
**** SNIPPET ****
Palindrome_Singly
bool isPalindrome(Node* head){
  //1.find middle element
   Node* slow = head;
   Node* fast = head;
   while(fast &&  fast->next){
    slow = slow->next;
    fast = fast->next->next;
   }
   //now slow is pointing to middle element
   //2. break the linked list in the middle 
   Node* curr = slow->next;
   Node* prev = slow;
   slow->next = NULL;
  //3. reverse the second half of linked list
   while(curr){
    Node* nextNode = curr->next;
    curr->next = prev;
    prev = curr;
    curr = nextNode;
   }
   // prev is the head pointer of the second node
   // to check two linkedlists are equal
   Node* head1 = head;
   Node* head2 = prev;
   while(head2){
    if(head1->val!=head2->val) {
        return false;
    }
     head1 = head1->next;
     head2 = head2->next;
   }
    return true;
}

**** TAGS ****

palindrome_Singly 
**** SNIPPET ****
findMiddleElement_Singly
Node* midleNode(Node* &head){
   Node* slow = head;
   Node* fast = head;
   while(fast!= NULL && fast->next!= NULL){
    slow = slow->next;
    fast = fast->next->next;
   }  
 return slow;
}

**** TAGS ****

tag_findMiddleElement_Singly 
**** SNIPPET ****
findLastIndexInArray
// Function to find the index of the last occurrence of a value in an array
int findLastIndexInArray(int arr[], int size, int value) {
    for (int i = size - 1; i >= 0; --i) {
        if (arr[i] == value) {
            return i;
        }
    }
    return -1; // Value not found
}

**** TAGS ****

findLastIndexArray 
**** SNIPPET ****
deleteBeginning_DoublyList
void deleteStart(Node* &head){
 if(head == NULL){
    cout<<"List is empty.No deletion perform!"<<endl;
 }
 Node* temp = head;
 head = head->next;
 if(head == NULL){//if head list have only one node
   tail = NULL;
 }
 else{
    head->prev = NULL;
 }
 free(temp);
}

**** TAGS ****

tag_deleteBeginning_DoublyList 
**** SNIPPET ****
arrayAverage
// Function to find the average of elements in an array
double arrayAverage(int arr[], int size) {
    if (size == 0)
        return 0;
    double sum = 0;
    for (int i = 0; i < size; ++i) {
        sum += arr[i];
    }
    return sum / size;
}

**** TAGS ****

arrayAverage 
**** SNIPPET ****
deleteAtHead_Singly
void deleteHead(Node* &head){
    if(head == NULL) return;
    Node *temp = head;
    head = head->next;
    free(temp); 
}

**** TAGS ****

Tag_DeleteAt_Head 
**** SNIPPET ****
arrayContainValue
bool vectorContains(vector<int> &vec, int value) {
    for (int num : vec) {
        if (num == value) {
            return true;
        }
    }
    return false;
}

**** TAGS ****

arrayContain_Array 
**** SNIPPET ****
squareRoot_Without_STL
void squareRoot(int x){
     int ans=-1;

    for(int i=1;i<= x;i++)
    {
    if(i*i<=x)
    {
        ans = i;
    }
    else break;
    }
    cout<<"Square root of "<<x<<" is: "<<ans;
    return;
}

**** TAGS ****

squareRoot_Without_Library 
**** SNIPPET ****
isArraySorted
// Function to check if an array is sorted in ascending order
bool isArraySorted(int arr[], int size) {
    for (int i = 0; i < size - 1; ++i) {
        if (arr[i] > arr[i + 1]) {
            return false;
        }
    }
    return true;
}

**** TAGS ****

isArraySorted 
**** SNIPPET ****
countEle_LessThanIn_Array
int countElementsLessThanValueInVector(const vector<int>& vec, int value) {
    int count = 0;
    for (int num : vec) {
        if (num < value) {
            count++;
        }
    }
    return count;
}

**** TAGS ****

countEle_LessthanIn_Array 
**** SNIPPET ****
insertPos_DoublyList
void insertPos(Node* &head,int value,int pos){
    //assuming pos is less or equal to length
    Node* temp = head;
    int count = 1;
    while(count<(pos-1)){
        temp = temp->next;
        count++;
    }
    //now temp is pointing to the pos-1 node
    Node* new_node = new Node(value);
    new_node->next = temp->next;
    temp->next = new_node;
    new_node->prev = temp;
    new_node->prev->next = new_node;
    return;
}

**** TAGS ****

tag_insertPos_DoublyList 
**** SNIPPET ****
radix_sort
void countSort(vector<int> &v,int pos)
{

    int n =v.size();

    //create frequency array

    vector<int> freq(10,0);

    for(int i=0;i<n;i++)
    {
        freq[(v[i]/pos)%10]++;
    }

    //cumulative frequency
    for(int i=1;i<10;i++)
    {
        freq[i]+=freq[i-1];
    }

    //ans array

    vector<int> ans(n);
     
    for(int i=n-1;i>=0;i--)
    {
        ans[--freq[(v[i]/pos)%10]] = v[i];
    }

    for(int i=0;i<n;i++)
    {
        v[i] = ans[i];
    }
   
}
void radixSort(vector<int> &v){

    
    int max_ele = v[0];
    
    for(auto x :v)
    {
        max_ele = max(x,max_ele);
    }

    for(int pos=1;max_ele/pos>0;pos*=10)
    {
        countSort(v,pos);
    }

}

**** TAGS ****

radix_sort 
**** SNIPPET ****
deleteEnd_CircularList
   void deleteEnd(){
    if(head==NULL){
        return;
    }
    Node* tail = head;
    while(tail->next->next!=head){
          tail = tail->next;
    }  
    //here tail is pointing to second last node
    Node* temp = tail->next;
    tail->next = head;
    free(temp);
}

**** TAGS ****

tag_deleteEnd_CircularList 
**** SNIPPET ****
length_Of_Singly_List
int getlength(Node* head){
   Node* temp = head;
   int len=0;
   while(temp!= NULL){
      len++;
      temp = temp->next;
   }
   return len;
}

**** TAGS ****

tag_Length_SinglyList 
**** SNIPPET ****
decode_string
string decodeString(string s){
    string result = "";
    //travesing the encoded string
    for(int i=0;i<s.length();i++)
    {
        if(s[i]!= ']'){
            result.push_back(s[i]);
        }
        else{
            //extract string from result
            string str = "";
            while(!result.empty() && result.back()!= '['){
                str.push_back(str.back());
                result.pop_back();
            }
            //reversing the str
            reverse(str.begin(),str.end()); 
            //extract num from result
             string nums ="";
             while(!result.empty() &&(result.back()>='0' && result.back()<='9'))
             {
                nums.push_back(result.back());
                result.pop_back();
             }
            //reversing the number string
              reverse(nums.begin(),nums.end());
            //convert string to integer
            int int_num =stoi(nums); 
            //inserting str in result int_num times
            while(int_num){
                result+=str;
                int_num--;
            }
        }  
    }
     return result;
}

**** TAGS ****

tag_decodeString 
**** SNIPPET ****
ArrangeOddEven_Singly
Node* oddEvenLL(Node* &head){
    if(head==NULL) return head;
   Node* evenHead = head->next;
   Node* oddptr = head;
   Node* evenptr = evenHead;
   while(evenptr!= NULL && evenptr->next!=NULL){
    oddptr->next = oddptr->next->next;
    evenptr->next = evenptr->next->next;
    oddptr = oddptr->next;
    evenptr = evenptr->next;
   }
   oddptr->next = evenHead;
   return head;
}

**** TAGS ****

tag_ArrangeOddEven_Singly 
**** SNIPPET ****
removeElementAtIndex_Array
// Function to remove an element at a specified index from a vector
void removeElementAtIndex(vector<int> &vec, int index) {
    if (index >= 0 && index < vec.size()) {
        vec.erase(vec.begin() + index);
    }
}

**** TAGS ****

removeElementAtIndex 
**** SNIPPET ****
deleteAtEnd_Singly
void deleteEnd(Node* &head){
     Node *second_last = head;
     while(second_last->next->next!= NULL){
        second_last = second_last->next;
     }
     //now second_last points to the second last node
     Node* temp = second_last->next;
     second_last->next = NULL;
     free(temp);
}

**** TAGS ****
deleteATEnd 
**** SNIPPET ****
sumOfElementsIn2DArray
int sumOfElementsIn2DArray(int arr[][3], int rows, int cols) {
    int sum = 0;
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            sum += arr[i][j];
        }
    }
    return sum;
}

**** TAGS ****

sumOfElementsIn2DArray 
**** SNIPPET ****
insertAtPos_Singly
void insert_Pos(Node* &head,int val,int pos){
     if(pos==0){
        insert_start(head,val);
        return;
     }
     Node* new_node = new Node(val);
     Node *temp = head;
     int curr_pos=0;
     while(curr_pos != pos-1){
        temp=temp->next;
        curr_pos++;
     } 
     //temp is pointing to node at pos-1
     new_node->next = temp->next;//temp->next is pointing to the at pos
      temp->next = new_node;
}

**** TAGS ****

tag_insertAtPos_Singly 
**** SNIPPET ****
arraySum
int arraySum(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; ++i) {
        sum += arr[i];
    }
    return sum;
}

**** TAGS ****

arraySum 
**** SNIPPET ****
fill2DArrayRandom
// Function to fill a 2D array with random numbers
void fill2DArrayRandom(int arr[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            arr[i][j] = rand() % 100; // Generate random numbers between 0 and 99
        }
    }
}

**** TAGS ****

fill2DArrayRandom 
**** SNIPPET ****
stackpeek
peek() const {
        if (isEmpty()) {
            std::cout << "Stack is empty!" << std::endl;
            throw std::runtime_error("Stack is empty");
        }
        return elements[top];
    }


**** TAGS ****

peek function in stack 
**** SNIPPET ****
stacksearch
int search(const T& item) const {
        for (int i = top; i >= 0; --i) {
            if (elements[i] == item) {
                return top - i + 1;
            }
        }
        return -1; // Element not found
    }


**** TAGS ****

search function of stack 
**** SNIPPET ****
stackisempty
bool isEmpty() const {
        return top == -1;
    }


**** TAGS ****

is empty function of stack 
**** SNIPPET ****
stacksize
int size() const {
        return top + 1;
    }


**** TAGS ****

size function of stack 
**** SNIPPET ****
stackpush
void push(const T& item) {
        if (top == capacity - 1) {
            std::cout << "Stack overflow!" << std::endl;
            return;
        }
        elements[++top] = item;
    }


**** TAGS ****

pushfunction in stack 
**** SNIPPET ****
stackcopy
Stack<T> copy() const {
        Stack<T> newStack(capacity);
        for (int i = 0; i <= top; ++i) {
            newStack.push(elements[i]);
        }
        return newStack;
    }


**** TAGS ****

copy function of stack 
**** SNIPPET ****
stackpop
pop() {
        if (isEmpty()) {
            std::cout << "Stack underflow!" << std::endl;
            throw std::runtime_error("Stack underflow");
        }
        return elements[top--];
    } 


**** TAGS ****

push function in stack 
**** SNIPPET ****
stackreverse
 void reverse() {
        Stack<T> tempStack(capacity);
        while (!isEmpty()) {
            tempStack.push(pop());
        }
        *this = tempStack;
    }


**** TAGS ****

reverse function of stack 
**** SNIPPET ****
stackmerge
void merge(Stack<T>& otherStack) {
        while (!otherStack.isEmpty()) {
            push(otherStack.pop());
        }
    }


**** TAGS ****

merge function of stack
**** SNIPPET ****
stackswap
void swap(Stack<T>& first, Stack<T>& second) {
        using std::swap;
        swap(first.elements, second.elements);
        swap(first.capacity, second.capacity);
        swap(first.top, second.top);
    }


**** TAGS ****

merge function of stack
**** SNIPPET ****
stackrotate
 void rotate(int positions) {
        if (!isEmpty()) {
            positions %= size();
            std::rotate(elements, elements + top - positions + 1, elements + top + 1);
        }
    }


**** TAGS ****

merge function of stack
**** SNIPPET ****
stackminimum
T getMinimum() const {
        if (isEmpty()) {
            throw std::runtime_error("Stack is empty");
        }
        T minElement = elements[0];
        for (int i = 1; i <= top; ++i) {
            if (elements[i] < minElement) {
                minElement = elements[i];
            }
        }
        return minElement;
    }


**** TAGS ****

minimum function of stack
**** SNIPPET ****
stackmaximum
T getMaximum() const {
        if (isEmpty()) {
            throw std::runtime_error("Stack is empty");
        }
        T maxElement = elements[0];
        for (int i = 1; i <= top; ++i) {
            if (elements[i] > maxElement) {
                maxElement = elements[i];
            }
        }
        return maxElement;
    }


**** TAGS ****

maximum function of stack
**** SNIPPET ****
stacksort
void sort() {
        std::sort(elements, elements + top + 1);
    }


**** TAGS ****

sort function of stack
**** SNIPPET ****
stackcontain
bool contains(const T& item) const {
        for (int i = 0; i <= top; ++i) {
            if (elements[i] == item) {
                return true;
            }
        }
        return false;
    }


**** TAGS ****

contain function of stack
**** SNIPPET ****
stackcount
int count(const T& item) const {
        int count = 0;
        for (int i = 0; i <= top; ++i) {
            if (elements[i] == item) {
                count++;
            }
        }
        return count;
    }


**** TAGS ****

count function of stack
**** SNIPPET ****
stackmergesort
void mergeSorted(Stack<T>& otherStack) {
        if (isEmpty()) {
            *this = otherStack;
        } else {
            Stack<T> mergedStack(size() + otherStack.size());
            while (!isEmpty() && !otherStack.isEmpty()) {
                if (peek() < otherStack.peek()) {
                    mergedStack.push(pop());
                } else {
                    mergedStack.push(otherStack.pop());
                }
            }
            while (!isEmpty()) {
                mergedStack.push(pop());
            }
            while (!otherStack.isEmpty()) {
                mergedStack.push(otherStack.pop());
            }
            *this = mergedStack;
        }
    }

    
**** TAGS ****

mergesortfunction of stack
**** SNIPPET ****
stackinterleave
void interleave(Stack<T>& otherStack) {
        Stack<T> tempStack(size() + otherStack.size());
        while (!isEmpty() && !otherStack.isEmpty()) {
            tempStack.push(pop());
            tempStack.push(otherStack.pop());
        }
        while (!isEmpty()) {
            tempStack.push(pop());
        }
        while (!otherStack.isEmpty()) {
            tempStack.push(otherStack.pop());
        }
        tempStack.reverse();
        *this = tempStack;
    }


**** TAGS ****

interleave function of stack
**** SNIPPET ****
stacksum
T sum() const {
    T result = 0;
    for (int i = 0; i <= top; ++i) {
        result += elements[i];
    }
    return result;
}


**** TAGS ****

sum function of stack
**** SNIPPET ****
stackproduct
T product() const {
    T result = 1;
    for (int i = 0; i <= top; ++i) {
        result *= elements[i];
    }
    return result;
}


**** TAGS ****

product function of stack
**** SNIPPET ****
stackclearuntil
void clearUntil(const T& item) {
    while (!isEmpty() && peek() != item) {
        pop();
    }
    if (!isEmpty()) {
        pop(); // Remove the specified element
    }
}


**** TAGS ****

clearuntil function of stack
**** SNIPPET ****
stackcduplicatenth
void duplicateNth(int n) {
    T element = elements[top - n + 1];
    push(element);
}


**** TAGS ****

clearduplicatenth function of stack
**** SNIPPET ****
stackremoveduplicate
void removeDuplicates() {
    Stack<T> tempStack(capacity);
    while (!isEmpty()) {
        T current = pop();
        if (!tempStack.contains(current)) {
            tempStack.push(current);
        }
    }
    while (!tempStack.isEmpty()) {
        push(tempStack.pop());
    }
}


**** TAGS ****

removeduplicates function of stack
**** SNIPPET ****
stackgetmedian
T getMedian() const {
    if (isEmpty()) {
        throw std::runtime_error("Stack is empty");
    }
    Stack<T> sortedStack = *this;
    sortedStack.sort();
    int size = sortedStack.size();
    if (size % 2 == 0) {
        return (sortedStack.elements[size / 2] + sortedStack.elements[size / 2 - 1]) / 2;
    } else {
        return sortedStack.elements[size / 2];
    }
}


**** TAGS ****

getmedian function of stack
**** SNIPPET ****
stackgetmode
T getMode() const {
    if (isEmpty()) {
        throw std::runtime_error("Stack is empty");
    }
    int maxFrequency = 0;
    T mode;
    for (int i = 0; i <= top; ++i) {
        int frequency = count(elements[i]);
        if (frequency > maxFrequency) {
            maxFrequency = frequency;
            mode = elements[i];
        }
    }
    return mode;
}


**** TAGS ****

getmode function of stack
**** SNIPPET ****
stacktruefalse
std::pair<Stack<T>, Stack<T>> partition(std::function<bool(const T&)> predicate) {
    Stack<T> trueStack(capacity);
    Stack<T> falseStack(capacity);
    while (!isEmpty()) {
        T current = pop();
        if (predicate(current)) {
            trueStack.push(current);
        } else {
            falseStack.push(current);
        }
    }
    return { trueStack, falseStack };
}


**** TAGS ****

gettruefalse function of stack
**** SNIPPET ****
stackrotateleft
void rotateLeft() {
    if (!isEmpty()) {
        T temp = pop();
        rotate(1);
        push(temp);
    }
}


**** TAGS ****

rotateleft function of stack
**** SNIPPET ****
stackrotateright
void rotateRight() {
    if (!isEmpty()) {
        T temp = elements[top];
        rotate(-1);
        elements[0] = temp;
    }
}


**** TAGS ****

rotateright function of stack
**** SNIPPET ****
stackshuffle
void shuffle() {
    std::random_shuffle(elements, elements + top + 1);
}


**** TAGS ****

shuffle function of stack
**** SNIPPET ****
stackgetelementat
T getElementAt(int index) const {
    if (index < 0 || index > top) {
        throw std::out_of_range("Index out of range");
    }
    return elements[index];
}


**** TAGS ****

getelementat function of stack
**** SNIPPET ****
stackgetfrequency
int getFrequency(const T& item) const {
    int frequency = 0;
    for (int i = 0; i <= top; ++i) {
        if (elements[i] == item) {
            frequency++;
        }
    }
    return frequency;
}


**** TAGS ****

getfrequency function of stack
**** SNIPPET ****
infixtopostfix
string infixToPostfix(const string& expression) {
    string postfix = "";
    stack<char> operatorStack;

    unordered_map<char, int> precedenceMap;
    precedenceMap['+'] = precedence('-');
    precedenceMap['-'] = precedence('+');
    precedenceMap['*'] = precedence('/');
    precedenceMap['/'] = precedence('*');
    precedenceMap['^'] = precedence('^');

    for (char c : expression) {
        if (isalnum(c)) {  // Operand
            postfix += c;
        } else if (c == '(') {
            operatorStack.push(c);
        } else if (c == ')') {
            while (!operatorStack.empty() && operatorStack.top() != '(') {
                postfix += operatorStack.top();
                operatorStack.pop();
            }
            operatorStack.pop();  // Discard the '('
        } else if (isOperator(c)) {
            while (!operatorStack.empty() && precedenceMap[c] <= precedenceMap[operatorStack.top()]) {
                postfix += operatorStack.top();
                operatorStack.pop();
            }
            operatorStack.push(c);
        }
    }

    // Append remaining operators in the stack to postfix
    while (!operatorStack.empty()) {
        postfix += operatorStack.top();
        operatorStack.pop();
    }

    return postfix;
}


**** TAGS ****

infixtopostfix function of stack
**** SNIPPET ****
infixtoprefix
string infixToPrefix(const string& expression) {
    string prefix = "";
    stack<char> operatorStack;

    unordered_map<char, int> precedenceMap;
    precedenceMap['+'] = precedence('-');
    precedenceMap['-'] = precedence('+');
    precedenceMap['*'] = precedence('/');
    precedenceMap['/'] = precedence('*');
    precedenceMap['^'] = precedence('^');

    for (int i = expression.size() - 1; i >= 0; i--) {
        char c = expression[i];
        if (isalnum(c)) {  // Operand
            prefix = c + prefix;
        } else if (c == ')') {
            operatorStack.push(c);
        } else if (c == '(') {
            while (!operatorStack.empty() && operatorStack.top() != ')') {
                prefix = operatorStack.top() + prefix;
                operatorStack.pop();
            }
            operatorStack.pop();  // Discard the ')'
        } else if (isOperator(c)) {
            while (!operatorStack.empty() && precedenceMap[c] < precedenceMap[operatorStack.top()]) {
                prefix = operatorStack.top() + prefix;
                operatorStack.pop();
            }
            operatorStack.push(c);
        }
    }
    // Append remaining operators in the stack to prefix
    while (!operatorStack.empty()) {
        prefix = operatorStack.top() + prefix;
        operatorStack.pop();
    }
    return prefix;
}


**** TAGS ****

infixtoprefix function of stack
**** SNIPPET ****
validparentheses
bool isValidParentheses(std::string s) {
    std::stack<char> stack;
    std::unordered_map<char, char> mapping = {{')', '('}, {']', '['}, {'}', '{'}};

    for (char c : s) {
        if (mapping.find(c) != mapping.end()) {
            char topElement = stack.empty() ? '#' : stack.top();
            if (topElement != mapping[c]) {
                return false;
            }
            stack.pop();
        } else {
            stack.push(c);
        }
    }
    return stack.empty();
}


**** TAGS ****

validparentheses function of stack
**** SNIPPET ****
evalRPN
int evalRPN(std::vector<std::string>& tokens) {
    std::stack<int> stack;

    for (const std::string& token : tokens) {
        if (token == "+" || token == "-" || token == "*" || token == "/") {
            int b = stack.top();
            stack.pop();
            int a = stack.top();
            stack.pop();
            if (token == "+") stack.push(a + b);
            else if (token == "-") stack.push(a - b);
            else if (token == "*") stack.push(a * b);
            else stack.push(a / b);
        } else {
            stack.push(std::stoi(token));
        }
    }
    return stack.top();
}


**** TAGS ****

evalRPN function of stack
**** SNIPPET ****
nextgreaterelement
std::vector<int> nextGreaterElement(std::vector<int>& nums) {
    std::vector<int> result(nums.size(), -1);
    std::stack<int> stack;

    for (int i = 0; i < nums.size(); ++i) {
        while (!stack.empty() && nums[i] > nums[stack.top()]) {
            result[stack.top()] = nums[i];
            stack.pop();
        }
        stack.push(i);
    }

    return result;
}


**** TAGS ****

nextgreaterelement function of stack
**** SNIPPET ****
simplifypath
std::string simplifyPath(std::string path) {
    std::stringstream ss(path);
    std::string token;
    std::stack<std::string> stack;
    while (getline(ss, token, '/')) {
        if (token == "" || token == ".") {
            continue;
        } else if (token == "..") {
            if (!stack.empty()) {
                stack.pop();
            }
        } else {
            stack.push(token);
        }
    }
    std::vector<std::string> vec;
    while (!stack.empty()) {
        vec.push_back(stack.top());
        stack.pop();
    }
    std::string result = "";
    for (int i = vec.size() - 1; i >= 0; --i) {
        result += "/" + vec[i];
    }
    return result.empty() ? "/" : result;
}


**** TAGS ****

simplifypath function of stack
**** SNIPPET ****
decodestring
std::string decodeString(std::string s) {
    std::stack<int> countStack;
    std::stack<std::string> stringStack;
    std::string currentString = "";
    int count = 0;
    for (char c : s) {
        if (isdigit(c)) {
            count = count * 10 + (c - '0');
        } else if (isalpha(c)) {
            currentString += c;
        } else if (c == '[') {
            countStack.push(count);
            stringStack.push(currentString);
            currentString = "";
            count = 0;
        } else if (c == ']') {
            int repeatTimes = countStack.top();
            countStack.pop();
            std::string tmp = "";
            for (int i = 0; i < repeatTimes; ++i) {
                tmp += currentString;
            }
            currentString = stringStack.top() + tmp;
            stringStack.pop();
        }
    }
    return currentString;
}


**** TAGS ****

decodestring function of stack
**** SNIPPET ****
inordertraversal
std::vector<int> inorderTraversal(TreeNode* root) {
    std::vector<int> result;
    std::stack<TreeNode*> stack;
    TreeNode* current = root;
    while (current != nullptr || !stack.empty()) {
        while (current != nullptr) {
            stack.push(current);
            current = current->left;
        }
        current = stack.top();
        stack.pop();
        result.push_back(current->val);
        current = current->right;
    }
    return result;
}


**** TAGS ****

inordertraversal function of stack
**** SNIPPET ****
towerofhanoi
void towerOfHanoi(int n)
{
    cout << "Tower of Hanoi for " << n << " disks:\n";
 
    int src = 0, aux = 1, dest = 2;
    for (int i = n; i > 0; i--)
        stacks[src].push(i);
 
    int totalMoves = (1 << n) - 1;
    if (n % 2 == 0)
        swap(aux, dest);
 
    for (int i = 1; i <= totalMoves; i++)
    {
        if (i % 3 == 0)
            moveDisk(aux, dest);
        else if (i % 3 == 1)
            moveDisk(src, dest);
        else
            moveDisk(src, aux);
    }
}


**** TAGS ****

towerofhanoi function of stack
**** SNIPPET ****
getmaxarea 
int getMaxArea(int hist[], int n) 
{ 
    stack<int> s; 
    int max_area = 0;
    int tp;
    int area_with_top;

    int i = 0; 
    while (i < n) { 
        if (s.empty() || hist[s.top()] <= hist[i]) 
            s.push(i++); 
        else { 
            tp = s.top(); 
            s.pop(); 
            area_with_top = hist[tp] * (s.empty() ? i : i - s.top() - 1); 
            if (max_area < area_with_top) 
                max_area = area_with_top; 
        } 
    } 

    while (s.empty() == false) { 
        tp = s.top(); 
        s.pop(); 
        area_with_top = hist[tp] * (s.empty() ? i : i - s.top() - 1); 
        if (max_area < area_with_top) 
            max_area = area_with_top; 
    } 

    return max_area; 
}


**** TAGS ****

getmaxarea function of stack
**** SNIPPET ****
removeconsecutiveSame
int removeConsecutiveSame(vector<string> v) 
{ 
    int n = v.size(); 
  
    for (int i = 0; i < n - 1; ) 
    { 
        if (v[i].compare(v[i+1]) == 0) 
        { 
            v.erase(v.begin() + i); 
            v.erase(v.begin() + i); 
            if (i > 0) 
                i--; 
            n = n - 2; 
        } 
        else
            i++; 
    } 
    return v.size(); 
}


**** TAGS ****

removeconsecutiveSame function of stack
**** SNIPPET ****
celebrity
int celebrity(vector<vector<int>>& M, int n){
    vector<int> adj[n + 1];
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(M[i][j] == 1){
                adj[i].push_back(j);
            }
        }
    }
    vector<int>::iterator it;
    for(int i = 0; i < n; i++){
        if(adj[i].empty()){
            bool flag = true;
            for(int j = 0; j < n; j++){
                if(i == j) continue;
                it = find(adj[j].begin(), adj[j].end(), i);
                if(it == adj[j].end()){
                    flag = false;
                    break;
                }
            }
            if(flag) return i;
        }
    }
    return -1;
}


**** TAGS ****

celebrity function of stack
**** SNIPPET ****
next_greater
void next_greater(int arr[], int query[], int n, int q) {
    for (int i = 0; i < q; i++) {
        int k = query[i];
        bool val = false;
        for (int j = k + 1; j < n; j++) {
            if (arr[j] > arr[k]) {
                cout << arr[j] << " ";
                val = true;
                break;
            }
        }
        if (val == false) {
            cout << -1 << " ";    
        }
    }
}


**** TAGS ****

next_greater function of stack
**** SNIPPET ****
postorderiterative
vector<int> postOrderIterative(struct Node* root) {
    vector<int> postOrderList;
    if (root == NULL)
        return postOrderList;
    stack<Node*> S;
    S.push(root);
    Node* prev = NULL;
    while (!S.empty()) {
        auto current = S.top();
        if (prev == NULL || prev->left == current || prev->right == current) {
            if (current->left)
                S.push(current->left);
            else if (current->right)
                S.push(current->right);
            else {
                S.pop();
                postOrderList.push_back(current->data);
            }
        } else if (current->left == prev) {
            if (current->right)
                S.push(current->right);
            else {
                S.pop();
                postOrderList.push_back(current->data);
            }
        } else if (current->right == prev) {
            S.pop();
            postOrderList.push_back(current->data);
        }
        prev = current;
    }
    return postOrderList;
}


**** TAGS ****

postorderiterative function of stack
**** SNIPPET ****
findmaxlen
int findMaxLen(string str) {
    int n = str.length();
    stack<int> stk;
    for (int i = 0; i < n; i++) {
        if (str[i] == '(')
            stk.push(i);
        else {
            if (!stk.empty() && str[stk.top()] == '(')
                stk.pop();
            else
                stk.push(i);
        }
    }

    int result = 0, last = n;
    while (!stk.empty()) {
        int now = stk.top();
        stk.pop();
        result = max(result, last - now - 1);
        last = now;
    }

    return max(result, last);
}


**** TAGS ****

findmaxlen function of stack
**** SNIPPET ****
emoveInvalidParenthesis
void removeInvalidParenthesis(string str) {
    if (str.empty())
        return;
 
    unordered_set<string> visit;
    queue<string> q;
    string temp;
    bool level;
 
    q.push(str);
    visit.insert(str);
    while (!q.empty()) {
        str = q.front();  
        q.pop();
        if (isValidString(str)) {
            cout << str << endl;
            level = true;
        }
        if (level)
            continue;
        for (int i = 0; i < str.length(); i++) {
            if (!isParenthesis(str[i]))
                continue;
            temp = str.substr(0, i) + str.substr(i + 1);
            if (visit.find(temp) == visit.end()) {
                q.push(temp);
                visit.insert(temp);
            }
        }
    }
}


**** TAGS ****

removeInvalidParenthesis function of stack
**** SNIPPET ****
noofaassignments
int noOfAssignments(string& S, int& n, int i,
                    int c_x, int c_y)
{
    if (F[i][c_x][c_y] != -1)
        return F[i][c_x][c_y];
    if (i == n) {
        F[i][c_x][c_y] = !c_x && !c_y;
        return F[i][c_x][c_y];
    }
    if (S[i] == '(') {
        F[i][c_x][c_y]
            = noOfAssignments(S, n, i + 1,
                              c_x + 1, c_y)
              + noOfAssignments(S, n, i + 1,
                                c_x, c_y + 1);
        return F[i][c_x][c_y];
    }
    F[i][c_x][c_y] = 0;
    if (c_x)
        F[i][c_x][c_y]
            += noOfAssignments(S, n, i + 1,
                               c_x - 1, c_y);
    if (c_y)
        F[i][c_x][c_y]
            += noOfAssignments(S, n, i + 1,
                               c_x, c_y - 1);
     return F[i][c_x][c_y];
}


**** TAGS ****

noofaassignments function of stack
**** SNIPPET ****
enqueue
void enqueue(const T& item) {
        elements.push(item);
    }


**** TAGS ****

enqueue function of queue
**** SNIPPET ****
dequeue
T dequeue() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        T frontElement = elements.front();
        elements.pop();
        return frontElement;
    }


**** TAGS ****

dequeue function of queue
**** SNIPPET ****
queueconst
T front() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return elements.front();
    }


**** TAGS ****

const function of queue
**** SNIPPET ****
queueisempty
bool isEmpty() const {
        return elements.empty();
    }


**** TAGS ****

isempty function of queue
**** SNIPPET ****
queuesize
int size() const {
        return elements.size();
    }


**** TAGS ****

size function of queue
**** SNIPPET ****
queueclear
void clear() {
        while (!isEmpty()) {
            elements.pop();
        }
    }


**** TAGS ****

clear function of queue
**** SNIPPET ****
queuepeek
T peek() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        return elements.front();
    }


**** TAGS ****

peek function of queue
**** SNIPPET ****
queuecontains
bool contains(const T& item) const {
        for (auto& element : elements) {
            if (element == item) {
                return true;
            }
        }
        return false;
    }


**** TAGS ****

peek function of queue
**** SNIPPET ****
queuecopy
Queue<T> copy() const {
        Queue<T> copyQueue;
        for (auto& element : elements) {
            copyQueue.enqueue(element);
        }
        return copyQueue;
    }


**** TAGS ****

copy function of queue
**** SNIPPET ****
queuereverse
void reverse() {
        std::queue<T> reversedQueue;
        while (!isEmpty()) {
            reversedQueue.push(front());
            elements.pop();
        }
        elements = reversedQueue;
    }


**** TAGS ****

reverse function of queue
**** SNIPPET ****
queuemerge
void merge(Queue<T>& otherQueue) {
        while (!otherQueue.isEmpty()) {
            enqueue(otherQueue.dequeue());
        }
    }


**** TAGS ****

merge function of queue
**** SNIPPET ****
queuesplit
std::pair<Queue<T>, Queue<T>> split(int index) {
        Queue<T> firstQueue;
        Queue<T> secondQueue;
        int count = 0;
        while (!isEmpty()) {
            if (count < index) {
                firstQueue.enqueue(dequeue());
            } else {
                secondQueue.enqueue(dequeue());
            }
            count++;
        }
        return { firstQueue, secondQueue };
    }


**** TAGS ****

split function of queue
**** SNIPPET ****
queueelementat
T getElementAt(int index) const {
        if (index < 0 || index >= size()) {
            throw std::out_of_range("Index out of range");
        }
        std::queue<T> tempQueue = elements;
        for (int i = 0; i < index; ++i) {
            tempQueue.pop();
        }
        return tempQueue.front();
    }


**** TAGS ****

elementat function of queue
**** SNIPPET ****
queuegetfrequency
int getFrequency(const T& item) const {
        int frequency = 0;
        std::queue<T> tempQueue = elements;
        while (!tempQueue.empty()) {
            if (tempQueue.front() == item) {
                frequency++;
            }
            tempQueue.pop();
        }
        return frequency;
    }


**** TAGS ****

getfrequency function of queue
**** SNIPPET ****
queuerotate
void rotate(int positions) {
        positions %= size();
        if (positions < 0) {
            positions += size();
        }
        for (int i = 0; i < positions; ++i) {
            T frontElement = dequeue();
            enqueue(frontElement);
        }
    }


**** TAGS ****

rotate function of queue
**** SNIPPET ****
queueswap
void swap(Queue<T>& otherQueue) {
        std::swap(elements, otherQueue.elements);
    }


**** TAGS ****

swap function of queue
**** SNIPPET ****
queueisfull
bool isFull() const {
        return size() == capacity;
    }


**** TAGS ****

isfull function of queue
**** SNIPPET ****
queuegetcapacity
int getCapacity() const {
        return capacity;
    }


**** TAGS ****

getcapacity function of queue
**** SNIPPET ****
queueresize
void resize(int newCapacity) {
        capacity = newCapacity;
    }


**** TAGS ****

resize function of queue
**** SNIPPET ****
queuestringtostring
std::string toString() const {
        std::ostringstream oss;
        oss << "[";
        std::queue<T> temp = elements;
        while (!temp.empty()) {
            oss << temp.front();
            temp.pop();
            if (!temp.empty()) {
                oss << ", ";
            }
        }
        oss << "]";
        return oss.str();
    }


**** TAGS ****

stringtostring function of queue
**** SNIPPET ****
queueclone
Queue<T> clone() const {
        Queue<T> copyQueue;
        std::queue<T> temp = elements;
        while (!temp.empty()) {
            copyQueue.enqueue(temp.front());
            temp.pop();
        }
        return copyQueue;
    }


**** TAGS ****

clone function of queue
**** SNIPPET ****
queueequal
bool equals(const Queue<T>& otherQueue) const {
        return elements == otherQueue.elements;
    }


**** TAGS ****

equal function of queue
**** SNIPPET ****
queueinsertat
void insertAt(int index, const T& item) {
        if (index < 0 || index > size()) {
            throw std::out_of_range("Index out of range");
        }
        std::queue<T> temp;
        while (!isEmpty()) {
            temp.push(dequeue());
        }
        for (int i = 0; i < index; ++i) {
            enqueue(temp.front());
            temp.pop();
        }
        enqueue(item);
        while (!temp.empty()) {
            enqueue(temp.front());
            temp.pop();
        }
    }


**** TAGS ****

ensertat function of queue
**** SNIPPET ****
queueremoveat
void removeAt(int index) {
        if (index < 0 || index >= size()) {
            throw std::out_of_range("Index out of range");
        }
        std::queue<T> temp;
        while (!isEmpty()) {
            temp.push(dequeue());
        }
        for (int i = 0; i < index; ++i) {
            enqueue(temp.front());
            temp.pop();
        }
        temp.pop();
        while (!temp.empty()) {
            enqueue(temp.front());
            temp.pop();
        }
    }


**** TAGS ****

removeat function of queue
**** SNIPPET ****
queuesort
void sort() {
        std::vector<T> sortedElements;
        while (!isEmpty()) {
            sortedElements.push_back(dequeue());
        }
        std::sort(sortedElements.begin(), sortedElements.end());
        for (const auto& elem : sortedElements) {
            enqueue(elem);
        }
    }


**** TAGS ****

sort function of queue
**** SNIPPET ****
queuegetminimum
T getMinimum() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        T minElement = front();
        std::queue<T> temp = elements;
        while (!temp.empty()) {
            minElement = std::min(minElement, temp.front());
            temp.pop();
        }
        return minElement;
    }


**** TAGS ****

getminimum function of queue
**** SNIPPET ****
queuegetmaximum
T getMaximum() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        T maxElement = front();
        std::queue<T> temp = elements;
        while (!temp.empty()) {
            maxElement = std::max(maxElement, temp.front());
            temp.pop();
        }
        return maxElement;
    }


**** TAGS ****

getmaximum function of queue
**** SNIPPET ****
queueinterleave
void interleave(Queue<T>& otherQueue) {
        Queue<T> interleavedQueue;
        while (!isEmpty() || !otherQueue.isEmpty()) {
            if (!isEmpty()) {
                interleavedQueue.enqueue(dequeue());
            }
            if (!otherQueue.isEmpty()) {
                interleavedQueue.enqueue(otherQueue.dequeue());
            }
        }
        *this = interleavedQueue;
    }


**** TAGS ****

interleave function of queue
**** SNIPPET ****
queueremovelast
void removeLast() {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        std::queue<T> temp;
        while (size() > 1) {
            temp.push(dequeue());
        }
        dequeue();
        while (!temp.empty()) {
            enqueue(temp.front());
            temp.pop();
        }
    }


**** TAGS ****

removelast function of queue
**** SNIPPET ****
queuegetlast
T getLast() const {
        if (isEmpty()) {
            throw std::runtime_error("Queue is empty");
        }
        std::queue<T> temp = elements;
        T lastElement;
        while (!temp.empty()) {
            lastElement = temp.front();
            temp.pop();
        }
        return lastElement;
    }


**** TAGS ****

getlast function of queue
**** SNIPPET ****
queuecontainsall
bool containsAll(const Queue<T>& otherQueue) const {
        std::queue<T> temp = otherQueue.elements;
        while (!temp.empty()) {
            if (!contains(temp.front())) {
                return false;
            }
            temp.pop();
        }
        return true;
    }


**** TAGS ****

containsall function of queue
**** SNIPPET ****
queuemergesort
void mergeSorted(Queue<T>& q1, Queue<T>& q2) {
        while (!q1.isEmpty() && !q2.isEmpty()) {
            if (q1.front() < q2.front()) {
                enqueue(q1.dequeue());
            } else {
                enqueue(q2.dequeue());
            }
        }
        while (!q1.isEmpty()) {
            enqueue(q1.dequeue());
        }
        while (!q2.isEmpty()) {
            enqueue(q2.dequeue());
        }
    }


**** TAGS ****

mergesort function of queue
**** SNIPPET ****
queuegetmedian
T getMedian() const {
        Queue<T> temp = *this;
        int size = temp.size();
        for (int i = 0; i < size / 2; ++i) {
            temp.dequeue();
        }
        if (size % 2 == 0) {
            return (temp.dequeue() + temp.front()) / 2;
        } else {
            return temp.dequeue();
        }
    }


**** TAGS ****

getmedian function of queue
**** SNIPPET ****
queuegetmode
T getMode() const {
        std::unordered_map<T, int> freqMap;
        while (!isEmpty()) {
            freqMap[front()]++;
            dequeue();
        }
        int maxFreq = 0;
        T mode;
        for (const auto& pair : freqMap) {
            if (pair.second > maxFreq) {
                maxFreq = pair.second;
                mode = pair.first;
            }
        }
        return mode;
    }


**** TAGS ****

getmode function of queue
**** SNIPPET ****
queuepartition
std::pair<Queue<T>, Queue<T>> partition(std::function<bool(const T&)> predicate) {
        Queue<T> trueQueue, falseQueue;
        while (!isEmpty()) {
            if (predicate(front())) {
                trueQueue.enqueue(dequeue());
            } else {
                falseQueue.enqueue(dequeue());
            }
        }
        return { trueQueue, falseQueue };
    }


**** TAGS ****

partition function of queue
**** SNIPPET ****
queuerotateleft
void rotateLeft() {
        enqueue(dequeue());
    }


**** TAGS ****

rotateleft function of queue
**** SNIPPET ****
queuerotateright
void rotateRight() {
        std::queue<T> temp;
        temp.push(back());
        dequeue();
        while (!isEmpty()) {
            temp.push(front());
            dequeue();
        }
        while (!temp.empty()) {
            enqueue(temp.front());
            temp.pop();
        }
    }


**** TAGS ****

rotateright function of queue
**** SNIPPET ****
queueshuffle
void shuffle() {
        std::vector<T> temp;
        while (!isEmpty()) {
            temp.push_back(front());
            dequeue();
        }
        std::random_device rd;
        std::mt19937 g(rd());
        std::shuffle(temp.begin(), temp.end(), g);
        for (const auto& elem : temp) {
            enqueue(elem);
        }
    }


**** TAGS ****

shuffle function of queue
**** SNIPPET ****
queuegetfrequency2
int getFrequency(const T& item) const {
        int frequency = 0;
        std::queue<T> temp = elements;
        while (!temp.empty()) {
            if (temp.front() == item) {
                frequency++;
            }
            temp.pop();
        }
        return frequency;
    }


**** TAGS ****

getfrequency2 function of queue
**** SNIPPET ****
queueremoveduplicate
void removeDuplicates() {
        std::unordered_set<T> seen;
        std::queue<T> temp;
        while (!isEmpty()) {
            if (seen.insert(front()).second) {
                temp.push(front());
            }
            dequeue();
        }
        elements = temp;
    }


**** TAGS ****

removeduplicates function of queue
**** SNIPPET ****
queuegetsubqueue
Queue<T> getSubQueue(int startIndex, int endIndex) const {
        if (startIndex < 0 || endIndex >= size() || startIndex > endIndex) {
            throw std::out_of_range("Invalid range");
        }
        Queue<T> subQueue;
        std::queue<T> temp = elements;
        for (int i = 0; i <= endIndex; ++i) {
            if (i >= startIndex) {
                subQueue.enqueue(temp.front());
            }
            temp.pop();
        }
        return subQueue;
    }


**** TAGS ****

getsubqueue function of queue
**** SNIPPET ****
queuereversefirstk
void reverseK(int k) {
        if (k < 0 || k > size()) {
            throw std::out_of_range("Invalid value of K");
        }
        std::stack<T> stack;
        for (int i = 0; i < k; ++i) {
            stack.push(front());
            dequeue();
        }
        while (!stack.empty()) {
            enqueue(stack.top());
            stack.pop();
        }
    }


**** TAGS ****

reversefirstk function of queue
**** SNIPPET ****
queuereplace
void replace(const T& oldElement, const T& newElement) {
        std::queue<T> temp;
        while (!isEmpty()) {
            if (front() == oldElement) {
                temp.push(newElement);
            } else {
                temp.push(front());
            }
            dequeue();
        }
        elements = temp;
    }


**** TAGS ****

queuereplace function of queue
**** SNIPPET ****
queuedistinctelements
Queue<T> getDistinctElements() const {
        std::unordered_set<T> seen;
        Queue<T> distinctQueue;
        std::queue<T> temp = elements;
        while (!temp.empty()) {
            if (seen.insert(temp.front()).second) {
                distinctQueue.enqueue(temp.front());
            }
            temp.pop();
        }
        return distinctQueue;
    }


**** TAGS ****

queuedistinctelements function of queue
**** SNIPPET ****
queuepopuntil
void popUntil(std::function<bool(const T&)> predicate) {
        while (!isEmpty() && !predicate(front())) {
            dequeue();
        }
    }


**** TAGS ****

popuntil function of queue
**** SNIPPET ****
queuepush
void push(const T& item, std::function<bool(const T&)> condition) {
        while (condition(item)) {
            enqueue(item);
        }
    }


**** TAGS ****

queuepush function of queue
**** SNIPPET ****
queueinsertsorted
void insertSorted(const T& item) {
        std::queue<T> temp;
        while (!isEmpty() && front() < item) {
            temp.push(front());
            dequeue();
        }
        temp.push(item);
        while (!isEmpty()) {
            temp.push(front());
            dequeue();
        }
        elements = temp;
    }


**** TAGS ****

insertsorted function of queue    


